commit 0bc87b849a582ee40e69e75cf5537532afea6b61
Author: Joris Steyn <joris@ibuildings.nl>
Date:   Mon Nov 5 11:49:07 2012 +0100

    Moved REST-api to 'Legacy' namespace (no bc-break)
    
    Added hard-coded support for prettier url's
    
    Added new REST-full read/write API (rest-v2)

diff --git a/modules/janus/config-templates/module_janus.php b/modules/janus/config-templates/module_janus.php
index 4440f5c..a5affa6 100644
--- a/modules/janus/config-templates/module_janus.php
+++ b/modules/janus/config-templates/module_janus.php
@@ -71,6 +71,25 @@ $config = array(
     ),
 
     /*
+     * Configuration of REST v2 API
+     */
+    'rest-api' => array(
+        'vendor-mime-type'      => 'application/vnd.organisation.edu-v2+json',
+        'authentication-realm'  => 'JANUS API v2',
+        'authentication-salt'   => '366fa2822099dbf184cfa35cca701ce8',
+        'metadata-filter-roles' => array(
+            'certdata' => array(
+                'roles'   => array('rest-certdata', 'rest-admin'),
+                'pattern' => '#certData.*#i',
+            ),
+            'contacts' => array(
+                'roles'   => array('rest-contacts', 'rest-admin'),
+                'pattern' => '#contacts:[0-9]+:.*.*#i',
+            )
+        ),
+    ),
+
+    /*
      * Configuration of systems in JANUS.
      */
     'workflowstates' => array(
@@ -788,6 +807,21 @@ $config = array(
         'administrative',
         'billing',
         'other',
+
+        // REST v2 API
+        'rest-admin',      // Allow all API actions
+        'rest-proxy',      // May read all information
+        'rest-sp-admin',   // May see and manage all SPs (but no IdPs)
+        'rest-idp-admin',  // May see and manage all IDPs (but no SPs)
+        'rest-idp',        // May only see and edit own IDPs (no prod/arp/acl/certdata/contacts)
+        'rest-sp',         // May only see and edit own SPs (no prod/arp/acl/certdata/contacts)
+
+        // rest-*-admin roles already have these privileges
+        'rest-prod',       // Additional write access to production-state entities
+        'rest-arp',        // Additional write access to ARP entry on SP
+        'rest-acl',        // Additional write access to Idp/SP ACL
+        'rest-certdata',   // Additional write access to Idp/SP ACL
+        'rest-contacts',   // Additional write access to Idp/SP ACL
     ),
 
     // Default type for subscriptions
diff --git a/modules/janus/dictionaries/dashboard.definition.json b/modules/janus/dictionaries/dashboard.definition.json
index f1f4bc7..bccf8f5 100644
--- a/modules/janus/dictionaries/dashboard.definition.json
+++ b/modules/janus/dictionaries/dashboard.definition.json
@@ -125,6 +125,9 @@
 	"admin_userid": {
 		"en": "User ID"
 	},
+	"admin_rest_secret": {
+		"en": "Secret (Optional, API)"
+	},
 	"admin_select_remove_user": {
 		"en": "Select user to remove"
 	},
diff --git a/modules/janus/lib/EntityController.php b/modules/janus/lib/EntityController.php
index 52ca777..5f8e47a 100644
--- a/modules/janus/lib/EntityController.php
+++ b/modules/janus/lib/EntityController.php
@@ -1128,7 +1128,7 @@ class sspmod_janus_EntityController extends sspmod_janus_Database
      */
     public function addAllowedEntity($remoteEid)
     {
-        assert('is_string($remoteid) && ctype_digit($remoteeid)');
+        assert('is_string($remoteEid) && ctype_digit($remoteEid)');
 
         if (!array_key_exists($remoteEid, $this->_allowed)) {
             $this->_allowed[$remoteEid] = array('remoteeid' => $remoteEid);
diff --git a/modules/janus/lib/REST/Exception.php b/modules/janus/lib/REST/Exception.php
new file mode 100644
index 0000000..328148a
--- /dev/null
+++ b/modules/janus/lib/REST/Exception.php
@@ -0,0 +1,24 @@
+<?php
+
+/**
+ * Generic exception class (translates to 500 Internal Server Error)
+ */
+class sspmod_janus_REST_Exception extends Exception
+    implements sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode()
+    {
+        return 500;
+    }
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage()
+    {
+        return 'Internal Server Error';
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/Exception/BadRequest.php b/modules/janus/lib/REST/Exception/BadRequest.php
new file mode 100644
index 0000000..4dfdd91
--- /dev/null
+++ b/modules/janus/lib/REST/Exception/BadRequest.php
@@ -0,0 +1,21 @@
+<?php
+
+class sspmod_janus_REST_Exception_BadRequest extends Exception
+    implements sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode()
+    {
+        return 400;
+    }
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage()
+    {
+        return 'Bad Request';
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/Exception/Conflict.php b/modules/janus/lib/REST/Exception/Conflict.php
new file mode 100644
index 0000000..2ab8eb8
--- /dev/null
+++ b/modules/janus/lib/REST/Exception/Conflict.php
@@ -0,0 +1,21 @@
+<?php
+
+class sspmod_janus_REST_Exception_Conflict extends Exception
+    implements sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode()
+    {
+        return 409;
+    }
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage()
+    {
+        return 'Conflict';
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/Exception/InternalServerError.php b/modules/janus/lib/REST/Exception/InternalServerError.php
new file mode 100644
index 0000000..b69cc4c
--- /dev/null
+++ b/modules/janus/lib/REST/Exception/InternalServerError.php
@@ -0,0 +1,21 @@
+<?php
+
+class sspmod_janus_REST_Exception_InternalServerError extends Exception
+    implements sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode()
+    {
+        return 500;
+    }
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage()
+    {
+        return 'Internal Server Error';
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/Exception/NotAuthorized.php b/modules/janus/lib/REST/Exception/NotAuthorized.php
new file mode 100644
index 0000000..219c69c
--- /dev/null
+++ b/modules/janus/lib/REST/Exception/NotAuthorized.php
@@ -0,0 +1,21 @@
+<?php
+
+class sspmod_janus_REST_Exception_NotAuthorized extends Exception
+    implements sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode()
+    {
+        return 401;
+    }
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage()
+    {
+        return 'Not Authorized';
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/Exception/NotFound.php b/modules/janus/lib/REST/Exception/NotFound.php
new file mode 100644
index 0000000..e17aa20
--- /dev/null
+++ b/modules/janus/lib/REST/Exception/NotFound.php
@@ -0,0 +1,21 @@
+<?php
+
+class sspmod_janus_REST_Exception_NotFound extends Exception
+    implements sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode()
+    {
+        return 404;
+    }
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage()
+    {
+        return 'Not Found';
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/Exception/NotImplemented.php b/modules/janus/lib/REST/Exception/NotImplemented.php
new file mode 100644
index 0000000..e8ebdf6
--- /dev/null
+++ b/modules/janus/lib/REST/Exception/NotImplemented.php
@@ -0,0 +1,21 @@
+<?php
+
+class sspmod_janus_REST_Exception_NotImplemented extends Exception
+    implements sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode()
+    {
+        return 501;
+    }
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage()
+    {
+        return 'Not Implemented';
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/HttpError.php b/modules/janus/lib/REST/HttpError.php
new file mode 100644
index 0000000..2acae0d
--- /dev/null
+++ b/modules/janus/lib/REST/HttpError.php
@@ -0,0 +1,14 @@
+<?php
+
+interface sspmod_janus_REST_HttpError
+{
+    /**
+     * @return int HTTP error code
+     */
+    public function getHttpErrorCode();
+
+    /**
+     * @return string HTTP error message
+     */
+    public function getHttpErrorMessage();
+}
diff --git a/modules/janus/lib/REST/Legacy/Methods.php b/modules/janus/lib/REST/Legacy/Methods.php
new file mode 100644
index 0000000..22e2a74
--- /dev/null
+++ b/modules/janus/lib/REST/Legacy/Methods.php
@@ -0,0 +1,636 @@
+<?php
+
+/**
+ * @deprecated by the v2 REST endpoint
+ */
+class sspmod_janus_REST_Legacy_Methods
+{
+    /**
+     * Blacklist of methods that are protected (and need authentication to use).
+     */
+    public static function isProtected($method)
+    {
+        $protected_methods = array(
+            'method_arp',
+            'method_getUser',
+            'method_getEntity',
+            'method_getMetadata',
+            'method_isConnectionAllowed',
+            'method_getAllowedIdps',
+            'method_getAllowedSps',
+            'method_getIdpList',
+            'method_getSpList',
+            'method_findIdentifiersByMetadata'
+        );
+
+        return in_array($method, $protected_methods);
+    }
+
+    /**
+     * Echo back input received, for uptime testing.
+     *
+     * @access public (see isProtected)
+     * @static
+     * @param array $data Request parameters for echo method, supports:
+     *                    - string $data['string']: string to echo back
+     * @return string
+     */
+    public static function method_echo($data)
+    {
+        if(isset($data['string'])) {
+            return $data['string'];
+        }
+
+        return 'JANUS';
+    }
+
+    /**
+     * Get the Attribute Release Policy for a given Entity
+     *
+     * @access protected (see isProtected public method)
+     * @static
+     * @param array $data Request parameters for arp method, supports:
+     *                      - string $data['entityid']: Entity ID to get ARP for
+     *                      - int    $data['revision']: Revision of Entity to get ARP for (if not set, last revision is used)
+     * @param int   $statusCode HTTP status code to return
+     * @return array|stdClass|string Attribute release policy data
+     */
+    public static function method_arp($data, &$statusCode)
+    {
+        if (!isset($data['entityid'])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $revisionId = null;
+        if (isset($data['revision']) && ctype_digit($data['revision'])) {
+            $revisionId = $data['revision'];
+        }
+
+        $entityController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $entityController->setEntity($data['entityid'], $revisionId);
+
+        $arp = $entityController->getArp();
+        if (!$arp) {
+            // no arp set for this SP
+            return new stdClass();
+        }
+
+        $result = array();
+        $result['name']         = $arp->getName();
+        $result['description']  = $arp->getDescription();
+        $result['attributes']   = $arp->getAttributes();
+
+        return $result;
+    }
+
+    /**
+     * Get User information
+     *
+     * @access protected (see isProtected)
+     * @static
+     * @param array $data Request parameters for getUser method, supports:
+     *                      - string $data['userid']: UserID (login name) to get data for
+     * @param int $statusCode HTTP Status code to use in response
+     * @return array|string User information
+     */
+    public static function method_getUser($data, &$statusCode)
+    {
+        if (!isset($data["userid"])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $config = SimpleSAML_Configuration::getConfig('module_janus.php');
+        $user = new sspmod_janus_User($config->getValue('store'));
+        $user->setUserid($data['userid']);
+        $user->load(sspmod_janus_User::USERID_LOAD);
+
+        $result = array();
+        $result['uid']      = $user->getUid();
+        $result['userid']   = $user->getUserid();
+        $result['active']   = $user->getActive();
+        $result['type']     = $user->getType();
+        $result['data']     = $user->getdata();
+
+        return $result;
+    }
+
+    /**
+     * Get Entity Information.
+     *
+     * @access protected (see isProtected)
+     * @static
+     * @param array $data Request parameters for getEntity method, supports:
+     *                      - string $data['entityid']: Entity ID to get information
+     *                      - int    $data['revision']: Revision of Entity to get information for (if not set, last revision is used)
+     * @param int $statusCode HTTP Status code to use in response
+     * @return array|string Entity information
+     */
+    public static function method_getEntity($data, &$statusCode) {
+        if (!isset($data["entityid"])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $revisionId = null;
+        if (isset($data['revision']) && ctype_digit($data['revision'])) {
+            $revisionId = $data['revision'];
+        }
+
+        $entityController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $entity = $entityController->setEntity($data['entityid'], $revisionId);
+
+        $result = array();
+        $result['eid']          = $entity->getEid();
+        $result['entityid']     = $entity->getEntityid();
+        $result['revision']     = $entity->getRevisionid();
+        $result['parent']       = $entity->getParent();
+        $result['revisionnote'] = $entity->getRevisionnote();
+        $result['type']         = $entity->gettype();
+        $result['allowedall']   = $entity->getAllowedAll();
+        $result['workflow']     = $entity->getWorkflow();
+        $result['metadataurl']  = $entity->getMetadataURL();
+        $result['prettyname']   = $entity->getPrettyname();
+        $result['arp']          = $entity->getArp();
+        $result['manipulation'] = $entity->getManipulation();
+        $result['user']         = $entity->getUser();
+
+        return $result;
+    }
+
+    /**
+     * Get Entity metadata entries, note that this does not include the information about the entity that JANUS has.
+     *
+     * @access protected (see isProtected)
+     * @static
+     * @param array $data Request parameters for getMetadata method, supports:
+     *                      - string $data['entityid']: Entity ID to get information
+     *                      - int    $data['revision']: Revision of Entity to get information for (if not set, last revision is used)
+     *                      - string $data['keys']: Output keys
+     * @param int $statusCode HTTP Status code to use in response
+     * @return array|string Entity metadata
+     */
+    public static function method_getMetadata($data, &$statusCode)
+    {
+        if (!isset($data["entityid"])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $revisionId = null;
+        if (isset($data['revision']) && ctype_digit($data['revision'])) {
+            $revisionId = $data['revision'];
+        }
+
+        $keys = array();
+        if (isset($data["keys"])) {
+            $keys = explode(",", $data["keys"]);
+        }
+
+        $result = self::_getMetadataForEntity($data["entityid"], $revisionId, $keys);
+        if (!$result) {
+            $statusCode = 404;
+        }
+
+        return $result;
+    }
+
+    /**
+     * Is an SP allowed to connect to a certain IDP? (checks the SP's & IDP's white and blacklist).
+     *
+     * @access protected (see isProtected)
+     * @static
+     * @param array $data Request parameters for getMetadata method, supports:
+     *                      - string $data['spentityid']: Service Provider Entity ID to check
+     *                      - int    $data['sprevision']: Revision of Service Provider to get information for (if not set, last revision is used)
+     *                      - string $data['idpentityid']: Identity Provider Entity ID to check
+     *                      - int    $data['idprevision']: Revision of Identity Provider to get information for (if not set, last revision is used)
+     * @param int $statusCode HTTP Status code to use in response
+     * @return array|string Whether the connection is allowed
+     */
+    public static function method_isConnectionAllowed($data, &$statusCode)
+    {
+        if (!isset($data["spentityid"]) || !isset($data["idpentityid"])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $spRevisionId = null;
+        if(isset($data['sprevision']) && ctype_digit($data['sprevision'])) {
+            $spRevisionId = $data['sprevision'];
+        }
+
+        // Check the SP metadata whether the SP-IdP connection is allowed.
+        $isSpAllowed = self::_checkSPMetadataIsConnectionAllowed(
+            $data['spentityid'],
+            $data['idpentityid'],
+            $spRevisionId
+        );
+
+
+        $idpRevisionId = null;
+        if(isset($data['idprevision']) && ctype_digit($data['idprevision'])) {
+            $idpRevisionId = $data['idprevision'];
+        }
+
+        // Check the IdP metadata whether the SP-IdP connection is allowed.
+        $isIdpAllowed = self::_checkIdpMetadataIsConnectionAllowed(
+            $data['spentityid'],
+            $data['idpentityid'],
+            $idpRevisionId
+        );
+
+        return ($isSpAllowed && $isIdpAllowed) ? array(true) : array(false);
+    }
+
+    /**
+     * Get only the Identity Providers that a Service Provider is allowed to connect to.
+     *
+     * @access protected (see isProtected)
+     * @static
+     * @param array $data Request parameters for getMetadata method, supports:
+     *                      - string $data['spentityid']: Service Provider Entity ID to check
+     *                      - int    $data['sprevision']: Revision of Service Provider to get information for (if not set, last revision is used)
+     * @param int $statusCode HTTP Status code to use in response
+     * @return array|string Allowed Identity Providers
+     */
+    public static function method_getAllowedIdps($data, &$statusCode)
+    {
+        if (!isset($data['spentityid'])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $revisionId = null;
+        if (isset($data['sprevision']) && ctype_digit($data['sprevision'])) {
+            $revisionId = $data['sprevision'];
+        }
+
+        $userController   = new sspmod_janus_UserController((SimpleSAML_Configuration::getConfig('module_janus.php')));
+        $entityController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $entityController->setEntity($data['spentityid'], $revisionId);
+
+        $idpEntityIds = array();
+        if ($entityController->getAllowedAll() === "yes") {
+            // Get the Eids for all Identity Providers
+            $idpEntityIds = array_map(
+                function(sspmod_janus_Entity $entity) { return $entity->getEntityid(); },
+                $userController->searchEntitiesByType('saml20-idp')
+            );
+        }
+        else {
+            $allowed = $entityController->getAllowedEntities();
+            $blocked = $entityController->getBlockedEntities();
+
+            if (count($allowed)) {
+                $idpEntityIds = array_map(
+                    function($allowedEntity) { return $allowedEntity['remoteentityid']; },
+                    $allowed
+                );
+            } else if (count($blocked)) {
+                $blocked = array_map(
+                    function($blockedEntity) { return $blockedEntity['remoteentityid']; },
+                    $blocked
+                );
+                $idpEntityIds = array_diff($idpEntityIds, $blocked);
+            }
+        }
+
+        $spEid = $entityController->getEntity()->getEid();
+
+        $results = array();
+        foreach ($idpEntityIds as $idpEntityId) {
+            if (self::_checkIdPMetadataIsConnectionAllowed($spEid, $idpEntityId, $revisionId)) {
+                $results[] = $idpEntityId;
+            }
+        }
+        return $results;
+    }
+
+    /**
+     * Get the Service Providers that a given Identiy Provder is allowed to connect to
+     *
+     * @access protected (see isProtected)
+     * @static
+     * @param array $data Request parameters for method, supports:
+     *                      - string $data['idpentityid']: Identity Provider Entity ID to check
+     *                      - int    $data['idprevision']: Revision of Identity Provider to get information for (if not set, last revision is used)
+     * @param int $statusCode HTTP Status code to use in response
+     * @return array|string Service Providers the Identity Provider is allowed to connect to
+     */
+    public static function method_getAllowedSps($data, &$statusCode)
+    {
+        if (!isset($data['idpentityid'])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $revisionId = null;
+        if (isset($data['idprevision']) && ctype_digit($data['idprevision'])) {
+            $revisionId = $data['idprevision'];
+        }
+
+        $userController   = new sspmod_janus_UserController((SimpleSAML_Configuration::getConfig('module_janus.php')));
+        $entityController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $entityController->setEntity($data['idpentityid'], $revisionId);
+
+        $entityIds = array();
+        if ($entityController->getAllowedAll() === "yes") {
+            $entityIds = array_map(
+                function(sspmod_janus_Entity $entity) { return $entity->getEntityId(); },
+                $userController->searchEntitiesByType('saml20-sp')
+            );
+        }
+        else {
+            $allowed = $entityController->getAllowedEntities();
+            $blocked = $entityController->getBlockedEntities();
+
+            if (count($allowed)) {
+                $entityIds = array_map(
+                    function($allowedEntity) { return $allowedEntity['remoteentityid']; },
+                    $allowed
+                );
+            } else if (count($blocked)) {
+                $blocked = array_map(
+                    function($blockedEntity) { return $blockedEntity['remoteentityid']; },
+                    $blocked
+                );
+                $entityIds = array_diff($entityIds, $blocked);
+            }
+        }
+
+        $results = array();
+        foreach ($entityIds as $entityId) {
+            if (self::_checkSPMetadataIsConnectionAllowed($entityId, $data['idpentityid'], $revisionId)) {
+                $results[] = $entityId;
+            }
+        }
+        return $results;
+    }
+
+    public static function method_findIdentifiersByMetadata($data, &$statusCode)
+    {
+        if (!isset($data["key"]) || !isset($data["value"]) || !isset($data['userid'])) {
+            $statusCode = 400;
+            return '';
+        }
+
+        $userController = new sspmod_janus_UserController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $userController->setUser($data['userid']);
+        $entities = $userController->searchEntitiesByMetadata($data['key'], $data['value']);
+
+        $result = array();
+        /** @var $entity sspmod_janus_Entity */
+        foreach($entities AS $entity) {
+            $result[] = $entity->getEntityId();
+        }
+
+        return $result;
+    }
+
+    /**
+     * Get Identity Providers
+     * @param array $data The request parameters (typically from $_REQUEST)
+     *        The entries in $data for this method are:
+     *
+     *        keys (optional) - one or more comma separated keys of metadata
+     *                          to retrieve.
+     *                          Note that keys that don't exist are silently
+     *                          discarded and won't be present in the output.
+     *        spentityid (optional) - List only those idps which are
+     *                                whitelisted against the SP identified by
+     *                                this parameter
+     * @return array Identity Provider as assoc array with entityId as key
+     */
+    public static function method_getIdpList($data)
+    {
+        $filter = array();
+
+        // here we have access to $this->_entityController->getBlockedEntities()
+        // but we need a whitelist approach.
+        if (isset($data["keys"]) && $data["keys"]!="") {
+            $filter = explode(",", $data["keys"]);
+        }
+
+        $spEntityId = NULL;
+        if (isset($data["spentityid"]) && $data["spentityid"]!="") {
+            $spEntityId = $data["spentityid"];
+        }
+
+        return self::_getFormattedEntitiesForType("saml20-idp", $filter, $spEntityId);
+    }
+
+    /**
+     * Get Service Providers
+     * @param array $data The request parameters (typically from $_REQUEST)
+     *        The entries in $data for this method are:
+     *
+     *        keys (optional) - one or more comma separated keys of metadata
+     *                          to retrieve.
+     *                          Note that keys that don't exist are silently
+     *                          discarded and won't be present in the output.
+     * @return array Service Provider as assoc array with entityId as key
+     */
+    public static function method_getSpList($data)
+    {
+        $filter = array();
+
+        if (isset($data["keys"]) && $data["keys"]!="") {
+            $filter = explode(",", $data["keys"]);
+
+            // We also need the identifier
+            if (!in_array("entityID", $filter)) {
+                $filter[] = "entityID";
+            }
+        }
+
+        return self::_getFormattedEntitiesForType("saml20-sp", $filter);
+    }
+
+    /**
+     * Get requested metadata for an entity.
+     *
+     * Note that we support eid, entityid or sspmod_janus_Entity as input for an entity)
+     * but we make sure it's always a sspmod_janus_Entity object after we're done.
+     *
+     * @static
+     * @param mixed $entity
+     * @param null  $revisionId
+     * @param array $keys
+     * @return array|bool
+     */
+    protected static function _getMetadataForEntity(&$entity, $revisionId = NULL, $keys=array())
+    {
+        $entityController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+
+        /** @var $entity sspmod_janus_Entity */
+        $entity = $entityController->setEntity($entity, $revisionId);
+        if (!$entity->getWorkflow()) {
+            return false;
+        }
+
+        $metadata = $entityController->getMetadata();
+
+        $result = array();
+        foreach($metadata AS $meta) {;
+            if (count($keys) == 0 || in_array($meta->getKey(), $keys)) {
+                $result[$meta->getKey()] = $meta->getValue();
+            }
+        }
+
+        return $result;
+    }
+
+    /**
+     * Retrieve all entity metadata for all entities of a certain type.
+     *
+     * @param String $type            Supported types: "saml20-idp" or "saml20-sp"
+     * @param Array  $keys            optional list of metadata keys to retrieve. Retrieves all if blank
+     * @param String $allowedEntityId if passed, returns only those entities that are
+     *                                 whitelisted against the given entity
+     * @return Array Metadata as EntityId -=> array( // data about entity );
+     */
+    protected static function _getFormattedEntitiesForType($type, $keys=array(), $allowedEntityId=NULL)
+    {
+        $entities = self::_getEntitiesForType($type, $allowedEntityId);
+
+        $result = array();
+        foreach($entities as $entity) {
+           $data = self::_getMetadataForEntity($entity, NULL, $keys);
+            /** @var $entity sspmod_janus_Entity */
+
+           // Add workflow state info for optional filtering at client side
+           $data['workflowState'] = $entity->getWorkflow();
+
+           /** @var $entityId string */
+           $entityId = $entity->getEntityId();
+           $result[$entityId] = $data;
+        }
+        return $result;
+    }
+
+    /**
+     * Get all entities for a given type (like saml20-idp or saml20-sp) and optional entity to check for access.
+     *
+     * @static
+     * @param string      $type        Type of entities to get
+     * @param null|string $forEntityId Entity (of opposite typ!) to check against.
+     * @return array Entities
+     */
+    protected static function _getEntitiesForType($type, $forEntityId = null)
+    {
+        $entityController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $userController   = new sspmod_janus_UserController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+
+        if (!$forEntityId) {
+            return $userController->searchEntitiesByType($type);
+        }
+
+        $entityController->setEntity($forEntityId);
+        $entityController->loadEntity();
+
+        if ($entityController->getEntity()->getAllowedAll()=='yes') {
+            return $userController->searchEntitiesByType($type);
+        }
+
+        $allowedEntities = $entityController->getAllowedEntities();
+        if (count($allowedEntities) > 0) {
+            return array_keys($allowedEntities);
+        }
+
+        // Check the blacklist
+        $blockedEntities = $entityController->getBlockedEntities();
+        if (count($blockedEntities) > 0) {
+            $allEntities = $userController->searchEntitiesByType($type);
+            $allEids = array();
+            /** @var $entity sspmod_janus_Entity */
+            foreach($allEntities as $entity) {
+                $allEids[] = $entity->getEid();
+            }
+            // Return all entities that are not in the blacklist
+            return array_diff($allEids, array_keys($blockedEntities));
+        }
+
+        // No entities allowed for this entity
+        return array();
+    }
+
+    /**
+     * Does the Service Provider allow a particular connection?
+     *
+     * @static
+     * @param string      $spEid        Service Provider to check against (either eid or entityId)
+     * @param string      $idpEid       Identity Provider to check for (either eid or entityId)
+     * @param null|string $spRevisionId Optional revision of SP to use
+     * @return bool Is the connection allowed?
+     */
+    protected static function _checkSPMetadataIsConnectionAllowed($spEid, $idpEid, $spRevisionId=NULL)
+    {
+        $spController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $spController->setEntity($spEid, $spRevisionId);
+
+        $idpController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $idpController->setEntity($idpEid);
+        $idpEntity = $idpController->getEntity();
+        if (!$idpEntity) {
+            return false;
+        }
+        $idpEid = $idpEntity->getEid();
+
+        if ($spController->getAllowedAll() === "yes") {
+            return true;
+        }
+
+        $allowedIdps = $spController->getAllowedEntities();
+        if (count($allowedIdps) && array_key_exists($idpEid, $allowedIdps)) {
+            return true;
+        }
+
+        $blockedIdps = $spController->getBlockedEntities();
+        if (count($blockedIdps) && !array_key_exists($idpEid, $blockedIdps)) {
+           return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Does the Identity Provider allow a particular connection?
+     *
+     * @static
+     * @param string      $spEid         Service Provider to check for
+     * @param string      $idpEid        Identity Provider to check against
+     * @param null|string $idpRevisionId Optional revision of IdP to use
+     * @return bool Is the connection allowed?
+     */
+    protected static function _checkIdPMetadataIsConnectionAllowed($spEid, $idpEid, $idpRevisionId=NULL)
+    {
+        $idpController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $idpController->setEntity($idpEid, $idpRevisionId);
+
+        $spController = new sspmod_janus_EntityController(SimpleSAML_Configuration::getConfig('module_janus.php'));
+        $spController->setEntity($spEid);
+        $spEntity = $spController->getEntity();
+        if (!$spEntity) {
+            return false;
+        }
+        $spEid = $spEntity->getEid();
+
+        if ($idpController->getAllowedAll() === "yes") {
+            return true;
+        }
+
+        $allowedSps = $idpController->getAllowedEntities();
+        if (count($allowedSps) > 0 && array_key_exists($spEid, $allowedSps)) {
+            return true;
+        }
+
+        $blockedSps = $idpController->getBlockedEntities();
+        if (count($blockedSps) > 0 && !array_key_exists($spEid, $blockedSps)) {
+            return true;
+        }
+
+        return false;
+    }
+}
diff --git a/modules/janus/lib/REST/Legacy/Request.php b/modules/janus/lib/REST/Legacy/Request.php
new file mode 100644
index 0000000..5cbcaf1
--- /dev/null
+++ b/modules/janus/lib/REST/Legacy/Request.php
@@ -0,0 +1,66 @@
+<?php
+
+/**
+ * @deprecated by the v2 REST endpoint
+ */
+class sspmod_janus_REST_Legacy_Request
+{
+    // Params from request (DIRTY)
+    private $_raw_data = array();
+    private $_request_vars = array();
+    private $_signature = null;
+    private $_key = null;
+    private $_method = null;
+
+    public function __construct() {}
+
+    public function setRawdata($data)
+    {
+        $this->_raw_data = $data;
+    }
+
+    public function getRawdata()
+    {
+        return $this->_raw_data;
+    }
+
+    public function setSignature($signature)
+    {
+        $this->_signature = $signature;
+    }
+
+    public function getSignature()
+    {
+        return $this->_signature;
+    }
+
+    public function setKey($key)
+    {
+        $this->_key = $key;
+    }
+
+    public function getKey()
+    {
+        return $this->_key;
+    }
+
+    public function setMethod($method)
+    {
+        $this->_method = $method;
+    }
+
+    public function getMethod()
+    {
+        return $this->_method;
+    }
+
+    public function setRequestVars($request_vars)
+    {
+        $this->_request_vars = $request_vars;
+    }
+
+    public function getRequestVars()
+    {
+        return $this->_request_vars;
+    }
+}
diff --git a/modules/janus/lib/REST/Legacy/Utils.php b/modules/janus/lib/REST/Legacy/Utils.php
new file mode 100644
index 0000000..d6f7bbe
--- /dev/null
+++ b/modules/janus/lib/REST/Legacy/Utils.php
@@ -0,0 +1,182 @@
+<?php
+
+/**
+ * @deprecated by the v2 REST endpoint
+ */
+class sspmod_janus_REST_Legacy_Utils
+{
+    public static function processRequest($data)
+    {
+        $request = new sspmod_janus_REST_Legacy_Request();
+
+        $request->setRawdata($data);
+
+        if(isset($data['janus_sig'])) {
+            $request->setSignature($data['janus_sig']);
+            unset($data['janus_sig']);
+        }
+        if(isset($data['janus_key'])) {
+            $request->setKey($data['janus_key']);
+        }
+        if(isset($data['method'])) {
+            $request->setMethod($data['method']);
+        } else {
+            return false;
+        }
+
+        $request->setRequestVars($data);
+
+        return $request;
+    }
+
+    public static function isSignatureValid(sspmod_janus_REST_Legacy_Request $request)
+    {
+        if(is_null($request->getKey())) {
+            return false;
+        }
+
+        $config = SimpleSAML_Configuration::getConfig('module_janus.php');
+        $user = new sspmod_janus_User($config->getValue('store'));
+        $user->setUserid($request->getKey());
+        $user->load(sspmod_janus_User::USERID_LOAD);
+        $shared_secret = $user->getSecret();
+
+        $data = $request->getRequestVars();
+
+        // Sort params
+        ksort($data);
+
+        $concat_string = '';
+
+        // Concat all params with values
+        foreach($data AS $key => $value) {
+            $concat_string .= $key . $value;
+        }
+        // Prepend shared secret
+        $prepend_secret = $shared_secret . $concat_string;
+
+        // Hash the string to the signature
+        $calculated_signature = hash('sha512', $prepend_secret);
+
+        return $request->getSignature() == $calculated_signature;
+    }
+
+    public static function sendResponse($status = 200, $body = '', $content_type = 'text/html')
+    {
+        // Set the status
+        header('HTTP/1.0 ' . $status . ' ' . sspmod_janus_REST_Legacy_Utils::getStatusCodeMessage($status));
+
+        // Set caching headers
+        header('Cache-Control: no-cache, must-revalidate');
+        header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
+
+        if($body != '') {
+            switch($content_type) {
+                case 'application/json':
+                    header('Content-type: application/json; charset=UTF-8');
+                    $body = json_encode($body);
+                    break;
+                case 'text/html':
+                    header('Content-type: text/html; charset=UTF-8');
+                    break;
+                default:
+                    header('Content-type: text/html; charset=UTF-8');
+                    break;
+            }
+            echo $body;
+            exit;
+        } else {
+            // If no body, send a generic response
+            header('Content-type: text/html');
+
+            // Servers don't always have a signature turned on (this is an apache directive "ServerSignature On")
+            $signature = ($_SERVER['SERVER_SIGNATURE'] == '') ? $_SERVER['SERVER_SOFTWARE'] . ' Server at ' . $_SERVER['SERVER_NAME'] . ' Port ' . $_SERVER['SERVER_PORT'] : $_SERVER['SERVER_SIGNATURE'];
+
+            $statusMessage = sspmod_janus_REST_Legacy_Utils::getStatusCodeMessage($status);
+            $body = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+                        <html>
+                            <head>
+                                <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
+                                <title>' . $status . ' ' . $statusMessage . '</title>
+                            </head>
+                            <body>
+                                <h1>' . $statusMessage . '</h1>
+                                <hr />
+                                <address>' . $signature . '</address>
+                            </body>
+                        </html>';
+
+            echo $body;
+            exit;
+        }
+    }
+
+    public static function getStatusCodeMessage($status)
+    {
+        $codes = Array(
+            100 => 'Continue',
+            101 => 'Switching Protocols',
+            200 => 'OK',
+            201 => 'Created',
+            202 => 'Accepted',
+            203 => 'Non-Authoritative Information',
+            204 => 'No Content',
+            205 => 'Reset Content',
+            206 => 'Partial Content',
+            300 => 'Multiple Choices',
+            301 => 'Moved Permanently',
+            302 => 'Found',
+            303 => 'See Other',
+            304 => 'Not Modified',
+            305 => 'Use Proxy',
+            306 => '(Unused)',
+            307 => 'Temporary Redirect',
+            400 => 'Bad Request',
+            401 => 'Unauthorized',
+            402 => 'Payment Required',
+            403 => 'Forbidden',
+            404 => 'Not Found',
+            405 => 'Method Not Allowed',
+            406 => 'Not Acceptable',
+            407 => 'Proxy Authentication Required',
+            408 => 'Request Timeout',
+            409 => 'Conflict',
+            410 => 'Gone',
+            411 => 'Length Required',
+            412 => 'Precondition Failed',
+            413 => 'Request Entity Too Large',
+            414 => 'Request-URI Too Long',
+            415 => 'Unsupported Media Type',
+            416 => 'Requested Range Not Satisfiable',
+            417 => 'Expectation Failed',
+            500 => 'Internal Server Error',
+            501 => 'Not Implemented',
+            502 => 'Bad Gateway',
+            503 => 'Service Unavailable',
+            504 => 'Gateway Timeout',
+            505 => 'HTTP Version Not Supported'
+        );
+
+        return (isset($codes[$status])) ? $codes[$status] : '';
+    }
+
+    public static function callMethod(sspmod_janus_REST_Legacy_request $request)
+    {
+        $method = 'method_' . $request->getMethod();
+
+        if(method_exists('sspmod_janus_REST_Legacy_Methods', $method)) {
+            if(sspmod_janus_REST_Legacy_Methods::isProtected($method)) {
+                if(!sspmod_janus_REST_Legacy_Utils::isSignatureValid($request)) {
+                    return array('status' => 401, 'data' => '');
+                }
+            }
+
+            $result = array('status' => 200);
+            $result['data'] = sspmod_janus_REST_Legacy_Methods::$method($request->getRequestVars(), $result['status']);
+        } else {
+            $result = array('status' => 404, 'data' => '');
+        }
+
+        return $result;
+    }
+}
diff --git a/modules/janus/lib/REST/Mapper/Abstract.php b/modules/janus/lib/REST/Mapper/Abstract.php
new file mode 100644
index 0000000..d5c9165
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/Abstract.php
@@ -0,0 +1,191 @@
+<?php
+
+abstract class sspmod_janus_REST_Mapper_Abstract
+{
+    /**
+     * @var sspmod_janus_UserController
+     */
+    protected static $_userController = null;
+
+    /**
+     * @var sspmod_janus_EntityController
+     */
+    protected static $_entityController = null;
+
+    /**
+     * @var SimpleSAML_Configuration
+     */
+    protected static $_config = null;
+
+    /**
+     * @var sspmod_janus_REST_Request
+     */
+    protected $_request = null;
+
+    /**
+     * @var sspmod_janus_REST_Response
+     */
+    protected $_response = null;
+
+    /**
+     * @param sspmod_janus_REST_Request $request
+     * @param sspmod_janus_REST_Response $response
+     */
+    public function __construct(sspmod_janus_REST_Request $request,
+        sspmod_janus_REST_Response $response)
+    {
+        $this->_request = $request;
+        $this->_response = $response;
+    }
+
+    /**
+     * @return array
+     * @throws sspmod_janus_REST_Exception_NotImplemented
+     */
+    public function getCollection()
+    {
+        throw new sspmod_janus_REST_Exception_NotImplemented();
+    }
+
+    /**
+     * @param string $id
+     * @throws sspmod_janus_REST_Exception_NotImplemented
+     */
+    public function get($id)
+    {
+        throw new sspmod_janus_REST_Exception_NotImplemented();
+    }
+
+    /**
+     * @throws sspmod_janus_REST_Exception_NotImplemented
+     */
+    public function put()
+    {
+        throw new sspmod_janus_REST_Exception_NotImplemented();
+    }
+
+    /**
+     * @param string $id
+     * @throws sspmod_janus_REST_Exception_NotImplemented
+     */
+    public function post($id)
+    {
+        throw new sspmod_janus_REST_Exception_NotImplemented();
+    }
+
+    /**
+     * @param string $id
+     * @throws sspmod_janus_REST_Exception_NotImplemented
+     */
+    public function delete($id)
+    {
+        throw new sspmod_janus_REST_Exception_NotImplemented();
+    }
+
+    /**
+     * @return \SimpleSAML_Configuration
+     */
+    public static function getConfig()
+    {
+        if (self::$_config === null) {
+            self::$_config = SimpleSAML_Configuration::getConfig('module_janus.php');
+        }
+
+        return self::$_config;
+    }
+
+    /**
+     * @return \sspmod_janus_UserController
+     */
+    public static function getUserController()
+    {
+        //! @todo fixme, doesn't seem to work when configured in module_janus.php
+        $orig = self::getConfig()->toArray();
+        $orig['access']['allentities']['role'] = array(
+            'rest-admin', 'rest-sp-admin', 'rest-idp-admin'
+        );
+
+        $config = new SimpleSAML_Configuration($orig, 'dummy');
+
+        if (self::$_userController === null) {
+            self::$_userController = new sspmod_janus_UserController($config);
+        }
+
+        return self::$_userController;
+    }
+
+    /**
+     * @return \sspmod_janus_EntityController
+     */
+    public static function getEntityController()
+    {
+        if (self::$_entityController === null) {
+            return self::resetEntityController();
+        }
+
+        return self::$_entityController;
+    }
+
+    /**
+     * @param sspmod_janus_REST_Request $request
+     * @return sspmod_janus_REST_PermissionManager
+     */
+    public static function getPermissionManager(sspmod_janus_REST_Request $request)
+    {
+        return new sspmod_janus_REST_PermissionManager($request);
+    }
+
+    /**
+     * @return \sspmod_janus_EntityController
+     */
+    public static function resetEntityController()
+    {
+        self::$_entityController = new sspmod_janus_EntityController(
+            self::getConfig()
+        );
+
+        return self::$_entityController;
+    }
+
+    /**
+     * Set id on janus Entity object, performs duck-typing on the
+     * id value:
+     *  - is_numeric: set eid
+     *  - else: set entityid
+     *
+     * @param sspmod_janus_Entity $entity
+     * @param int|string $id
+     * @param string $revision
+     * @return bool result
+     */
+    protected function _setEntityId(sspmod_janus_Entity $entity, $id, $revision = null)
+    {
+        if ($revision !== null) {
+            $entity->setRevisionid($revision);
+        }
+
+        if (is_numeric($id)) {
+            $entity->setEid($id);
+            if (!$entity->load()) {
+                //! @todo implement more accurate error handling in janus libs
+                throw new sspmod_janus_REST_Exception_NotFound(
+                    sprintf('Entity with ID \'%s\' not found', $id), null, $e
+                );
+            }
+
+            self::getEntityController()
+                ->setEntity($entity);
+
+            return true;
+        } else {
+            // not supported for two reasons:
+            //  1. entityid makes a very clumsy URL (https%253A%252F%252Fopenidp.feide.no%252F)
+            //  2. less REST-full having two handles for the same object
+            throw new sspmod_janus_REST_Exception_BadRequest(
+                'Resource can not contain entityid, use eid or a collection filter'
+            );
+        }
+
+        return true;
+    }
+}
diff --git a/modules/janus/lib/REST/Mapper/Arp.php b/modules/janus/lib/REST/Mapper/Arp.php
new file mode 100644
index 0000000..4084281
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/Arp.php
@@ -0,0 +1,53 @@
+<?php
+
+class sspmod_janus_REST_Mapper_Arp extends sspmod_janus_REST_Mapper_Abstract
+{
+    /**
+     * @return array
+     */
+    public function getCollection()
+    {
+        return $this->_getArpList();
+    }
+
+    /**
+     * @return array
+     */
+    public function get($id)
+    {
+        foreach ($this->_getArpList() as $arp) {
+            if ($arp['aid'] == $id) {
+                return array($arp);
+            }
+        }
+
+        throw new sspmod_janus_REST_Exception_NotFound(
+            "ARP with id '$id' not found"
+        );
+    }
+
+    /**
+     * @return array
+     */
+    protected function _getArpList()
+    {
+        $list = array();
+        foreach ($this->_getArpModel()->getARPList() as $arp) {
+            if (!empty($arp['attributes'])) {
+                $arp['attributes'] = unserialize($arp['attributes']);
+            }
+
+            $list[]= $arp;
+        }
+
+        return $list;
+    }
+
+    /**
+     * @return sspmod_janus_ARP
+     */
+    protected function _getArpModel()
+    {
+        return new sspmod_janus_ARP();
+    }
+}
diff --git a/modules/janus/lib/REST/Mapper/Idp.php b/modules/janus/lib/REST/Mapper/Idp.php
new file mode 100644
index 0000000..742b9ca
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/Idp.php
@@ -0,0 +1,9 @@
+<?php
+
+class sspmod_janus_REST_Mapper_Idp extends sspmod_janus_REST_Mapper_SamlEntity
+{
+    /**
+     * @var string idp/sp saml20 type
+     */
+    protected $_samlType = 'saml20-idp';
+}
diff --git a/modules/janus/lib/REST/Mapper/IdpMetadata.php b/modules/janus/lib/REST/Mapper/IdpMetadata.php
new file mode 100644
index 0000000..05b87d9
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/IdpMetadata.php
@@ -0,0 +1,9 @@
+<?php
+
+class sspmod_janus_REST_Mapper_IdpMetadata extends sspmod_janus_REST_Mapper_SamlMetadata
+{
+    /**
+     * @var string idp/sp saml20 type
+     */
+    protected $_samlType = 'saml20-idp';
+}
diff --git a/modules/janus/lib/REST/Mapper/SamlEntity.php b/modules/janus/lib/REST/Mapper/SamlEntity.php
new file mode 100644
index 0000000..6ff1bc1
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/SamlEntity.php
@@ -0,0 +1,532 @@
+<?php
+
+abstract class sspmod_janus_REST_Mapper_SamlEntity extends sspmod_janus_REST_Mapper_Abstract
+{
+    /**
+     * @var string idp/sp saml20 type
+     */
+    protected $_samlType = 'unknown';
+
+    /**
+     * @return array
+     */
+    public function getCollection()
+    {
+        $entities = self::getUserController()->getEntities();
+
+        $collection = array();
+
+        foreach ($entities as $entity) {
+            if ($entity->getType() === $this->_samlType) {
+                $collection[] = $this->_fromEntity($entity);
+            }
+        }
+
+        return $collection;
+    }
+
+    /**
+     * @param string $id
+     * @return array
+     */
+    public function get($id)
+    {
+        $entity = new sspmod_janus_Entity(
+            self::getConfig()
+        );
+
+        try {
+            $this->_setEntityId($entity, $id, $this->_request->getParameter('revision'));
+        } catch (Exception $e) {
+            // workaround for bad janus' error handling
+            if (!preg_match('/could not get newest revision/i', $e->getMessage())) {
+                throw $e;
+            }
+
+            throw new sspmod_janus_REST_Exception_NotFound(
+                sprintf('Entity with ID \'%s\' not found', $id)
+            );
+        }
+
+        // do not return an sp in /idp and vice versa
+        if ($entity->getType() !== $this->_samlType) {
+            throw new sspmod_janus_REST_Exception_NotFound(
+                sprintf('Entity with ID \'%s\' is not of type \'%s\'', $id, $this->_samlType)
+            );
+        }
+
+        return $this->_fromEntity($entity);
+    }
+
+    /**
+     *
+     * @param string $id
+     * @return array
+     */
+    public function post($id)
+    {
+        $params = $this->_request->getParameters();
+
+        $params['type'] = $this->_samlType;
+
+        unset($params['eid']);
+        unset($params['revisionid']);
+
+        // creates entity object
+        $entity = $this->_toEntity($id, $params);
+
+        $controller = self::getEntityController();
+        $controller->loadEntity();
+
+        // set prod/test workflow
+        if (isset($params['workflow'])) {
+            $this->_setWorkflowState($entity, $params['workflow']);
+        }
+
+        // update metadata, arp, blocked, allowed
+        $this->_updateRelations();
+
+        return $this->get($id);
+    }
+
+    /**
+     *
+     * @return array
+     */
+    public function put()
+    {
+        $params = $this->_request->getParameters();
+
+        unset($params['type']);
+        unset($params['eid']);
+        unset($params['revisionid']);
+
+        // use metadataurl as default entityid
+        if (empty($params['entityid']) && !empty($params['metadataurl'])) {
+            $params['entityid'] = $params['metadataurl'];
+        }
+
+        // check entityid
+        $controller = self::getUserController();
+        if ($controller->isEntityIdInUse($params['entityid'], $message)) {
+            // intentionally discarding $message
+            throw new sspmod_janus_REST_Exception_BadRequest(
+                sprintf('An entity with entityid \'%s\' already exists', $params['entityid'])
+            );
+        }
+
+        // check minimum values
+        if (empty($params['entityid'])) {
+            throw new sspmod_janus_REST_Exception_BadRequest(
+                "Missing required entityid, provide at least 'metadataurl' or 'entityid' in the request body"
+            );
+        }
+
+        $params['type'] = $this->_samlType;
+
+        $controller = self::getEntityController();
+        $entity = $this->_toEntity(null, $params);
+
+        //! @todo improve error reporting
+        $controller->loadEntity();
+
+        // set prod/test workflow
+        if (isset($params['workflow'])) {
+            $this->_setWorkflowState($entity, $params['workflow']);
+        } else {
+            $defaultState = self::getConfig()->getValue('workflowstate.default');
+
+            $this->_setWorkflowState($entity, $defaultState);
+        }
+
+        try {
+            // update metadata, arp, blocked, allowed
+            $this->_updateRelations();
+        } catch (Exception $e) {
+            $this->_getAdminUtil()->deleteEntity($entity->getEid());
+
+            throw $e;
+        }
+
+        return $this->get($entity->getEid());
+    }
+
+    /**
+     * @param string $id
+     * @param array $parent
+     * @throws sspmod_janus_REST_Exception_InternalServerError
+     */
+    public function delete($id, array $parent = null)
+    {
+        $entity = $this->get($id);
+
+        //! @todo implement error handling
+        $this->_getAdminUtil()->deleteEntity($entity['eid']);
+    }
+
+    /**
+     * @param sspmod_janus_Entity $entity
+     * @param string $newState
+     * @return sspmod_janus_REST_Mapper_SamlEntity
+     */
+    protected function _setWorkflowState(sspmod_janus_Entity $entity, $newState)
+    {
+        if (
+            ($entity->getWorkflow() === 'prodaccepted') ||
+            ($newState === 'prodaccepted')
+        ) {
+            $user    = self::getUserController()->getUser();
+            $manager = self::getPermissionManager($this->_request);
+
+            if (!$manager->hasRole($user, array('rest-admin', 'rest-prod'))) {
+                throw new sspmod_janus_REST_Exception_NotAuthorized(
+                    'You are not authorized for production settings'
+                );
+            }
+        }
+
+        $entity->setWorkflow($newState);
+    }
+
+    /**
+     * @param sspmod_janus_Entity $entity
+     * @return array
+     */
+    protected function _fromEntity(sspmod_janus_Entity $entity)
+    {
+        $result = array();
+
+        foreach ($this->_getMapping() as $entityKey => $apiKey) {
+            $method = 'get' . ucfirst($entityKey);
+
+            // hard-code exceptions
+            if ($method === 'getType') {
+                $method = 'gettype';
+            }
+
+            if (!is_callable(array($entity, $method))) {
+                throw new sspmod_janus_REST_Exception_InternalServerError(
+                    "Unknown key \'$entityKey\' in mapping of SAMLEntity"
+                );
+            }
+
+            $result[$apiKey] = $entity->{$method}();
+        }
+
+        $controller = self::getEntityController();
+        $controller->setEntity($entity);
+
+        // add metadata
+        $result['metadata'] = array();
+        foreach ($controller->getMetadata() as $md) {
+            $result['metadata'][$md->getKey()] = $md->getValue();
+        }
+
+        // get ARP
+        if ($this->_samlType === 'saml20-idp') {
+            $result['disableconsent'] = $this->_getLinkedEntities('disableConsent');
+        } else {
+            $arp = $controller->getArp();
+            if ($arp instanceof sspmod_janus_ARP) {
+                // add arp entries
+                $result['arp'] = $arp->getAid();
+            } else {
+                $result['arp'] = null;
+            }
+        }
+
+        $result['allowed'] = $this->_getLinkedEntities('allowed');
+        $result['blocked'] = $this->_getLinkedEntities('blocked');
+        $result['workflow'] = $entity->getWorkflow();
+
+        return $result;
+    }
+
+    /**
+     * @param string $id
+     * @param array $data
+     * @param int $revision
+     * @return sspmod_janus_Entity $entity
+     */
+    protected function _toEntity($id, array $data, $revision = null)
+    {
+        $createNew = $this->_request->isPut();
+
+        $entity = new sspmod_janus_Entity(
+            self::getConfig(), $createNew
+        );
+
+        if (!$createNew) {
+            $this->_setEntityId($entity, $id, $revision);
+        } else {
+            self::getEntityController()->setEntity($entity);
+        }
+
+        // check permissions
+        $manager = self::getPermissionManager($this->_request);
+        $user    = self::getUserController()->getUser();
+
+        foreach ($data as $field => $value) {
+            if (!$manager->hasFieldPermissions($user, $field)) {
+                throw new sspmod_janus_REST_Exception_NotAuthorized(sprintf(
+                    'Specific rights must be granted for field \'%s\'', $field
+                ));
+            }
+        }
+
+        // apply mapping
+        foreach ($this->_getMapping() as $entityKey => $apiKey) {
+            if (!isset($data[$apiKey])) {
+                continue;
+            }
+
+            $method = 'set' . ucfirst($entityKey);
+
+            // hard-code exceptions
+            if ($method === 'setType') {
+                $method = 'settype';
+            }
+
+            if (!is_callable(array($entity, $method))) {
+                throw new sspmod_janus_REST_Exception_InternalServerError(
+                    "Unknown key \'$entityKey\' in mapping of SAMLEntity"
+                );
+            }
+
+            $entity->{$method}(
+                $data[$apiKey]
+            );
+        }
+
+        return $entity;
+    }
+
+    /**
+     * Get blocked/allowed entities list
+     *
+     * @param string $type 'allowed' or 'blocked'
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    protected function _getLinkedEntities($type)
+    {
+        // get entities
+        if ($type === 'blocked') {
+            $entities = self::getEntityController()->getBlockedEntities();
+        } else if ($type === 'allowed') {
+            $entities = self::getEntityController()->getAllowedEntities();
+        } else {
+            $entities = self::getEntityController()->getDisableConsent();
+        }
+
+        $result = array();
+
+        foreach ($entities as $entity) {
+            if (isset($entity['remoteeid'])) {
+                $result[] = $entity['remoteeid'];
+            } else {
+                $result[] = $entity['remoteentityid'];
+            }
+        }
+
+        return $result;
+    }
+
+    /**
+     * Updates metadata, arp, blocked, allowed from request
+     * to database
+     *
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    protected function _updateRelations()
+    {
+        $controller = self::getEntityController();
+
+        $this->_addEntityMetadata($controller)
+             ->_addEntityBlocked($controller)
+             ->_addEntityAllowed($controller);
+
+        if ($this->_samlType === 'saml20-idp') {
+             $this->_addEntityDisableConsent($controller);
+        } else {
+             $this->_addEntityArp($controller);
+        }
+
+        $controller->saveEntity();
+    }
+
+    /**
+     * Save entity metadata
+     *
+     * @param sspmod_janus_EntityController $controller
+     * @return \sspmod_janus_REST_Mapper_SamlEntity
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    protected function _addEntityMetadata(sspmod_janus_EntityController $controller) {
+        $user     = self::getUserController()->getUser();
+        $manager  = self::getPermissionManager($this->_request);
+        $metadata = $this->_request->getParameter('metadata', array());
+        $filters  = self::getConfig()->getConfigItem('rest-api')->getArray('metadata-filter-roles');
+
+        foreach ($metadata as $name => $value) {
+            foreach ($filters as $filterName => $filter) {
+                if (!preg_match($filter['pattern'], $name)) {
+                    continue; // not filtered
+                }
+
+                if ($manager->hasRole($user, $filter['roles'])) {
+                    continue;
+                }
+
+                throw new sspmod_janus_REST_Exception_NotAuthorized(sprintf(
+                    'Not authorized for write access to metadata field \'%s\' by filter \'%s\'',
+                    $name, $filterName
+                ));
+            }
+
+            if ($value === null) {
+                // delete metadata
+                $controller->removeMetadata($name);
+
+                continue;
+            }
+
+            foreach ($controller->getMetadata() as $md) {
+                if (($md->getKey() === $name) && ($md->getValue() === $value)) {
+                    continue; // value already there, all OK
+                }
+            }
+
+            if (!$controller->addMetadata($name, $value)) {
+                // ignore errors for POST (updating twice should be OK)
+                if (!$controller->updateMetadata($name, $value) && $this->_request->isPut()) {
+                    throw new sspmod_janus_REST_Exception_BadRequest(
+                        "Invalid value or unknown metadata field '{$name}'"
+                    );
+                }
+            }
+        }
+
+        return $this;
+    }
+
+    /**
+     * Add entity arp entry
+     *
+     * @param sspmod_janus_EntityController $controller
+     * @return \sspmod_janus_REST_Mapper_SamlEntity
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    protected function _addEntityArp(sspmod_janus_EntityController $controller) {
+        if ($this->_request->hasParameter('arp')) {
+            $arp     = $this->_request->getParameter('arp');
+            $user    = self::getUserController()->getUser();
+            $manager = self::getPermissionManager($this->_request);
+
+            if (!$manager->hasRole($user, array('rest-arp', 'rest-admin'))) {
+                throw new sspmod_janus_REST_Exception_NotAuthorized(
+                    'Not authorized for ARP updates'
+                );
+            }
+
+            $controller->setArp(($arp) ? $arp : '0');
+        }
+
+        return $this;
+    }
+
+    /**
+     * Add blocked entities
+     *
+     * @param sspmod_janus_EntityController $controller
+     * @return \sspmod_janus_REST_Mapper_SamlEntity
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    protected function _addEntityAllowed(sspmod_janus_EntityController $controller) {
+        if ($this->_request->hasParameter('allowed')) {
+            $allowed = (array)$this->_request->getParameter('allowed');
+            if ($allowed === null || $allowed === array()) {
+                $controller->clearAllowedEntities();
+            } else {
+                foreach ($allowed as $allowEid) {
+                    $controller->addAllowedEntity($allowEid);
+                }
+            }
+        }
+
+        return $this;
+    }
+
+    /**
+     * Add allowed entities
+     *
+     * @param sspmod_janus_EntityController $controller
+     * @return \sspmod_janus_REST_Mapper_SamlEntity
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    protected function _addEntityBlocked(sspmod_janus_EntityController $controller) {
+        if ($this->_request->hasParameter('blocked')) {
+            $blocked = (array)$this->_request->getParameter('blocked');
+            if ($blocked === null || $blocked === array()) {
+                $controller->clearBlockedEntities();
+            } else {
+                foreach ($blocked as $blockEid) {
+                    $controller->addBlockedEntity($blockEid);
+                }
+            }
+        }
+
+        return $this;
+    }
+
+
+    /**
+     * Add disable consent entities
+     *
+     * @param sspmod_janus_EntityController $controller
+     * @return \sspmod_janus_REST_Mapper_SamlEntity
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    protected function _addEntityDisableConsent(sspmod_janus_EntityController $controller) {
+        if ($this->_request->hasParameter('disableconsent')) {
+            $requested = (array)$this->_request->getParameter('disableconsent');
+            if ($requested === null || $requested === array()) {
+                $controller->clearConsent();
+            } else {
+                foreach ($requested as $eid) {
+                    $controller->addDisableConsent($eid);
+                }
+            }
+        }
+
+        return $this;
+    }
+
+    /**
+     * @return array mapping janus entity key => API key
+     */
+    protected function _getMapping()
+    {
+        return array(
+            'eid'          => 'eid',
+            'entityid'     => 'entityid',
+            'parent'       => 'parent',
+            'revisionid'   => 'revisionid',
+            'revisionnote' => 'revisionnote',
+            'type'         => 'type',
+            'allowedAll'   => 'allowedall',
+            'metadataURL'  => 'metadataurl',
+            'arp'          => 'arp',
+            'prettyname'   => 'prettyname',
+            'manipulation' => 'manipulation',
+            'user'         => 'user',
+        );
+    }
+
+    /**
+     * @return sspmod_janus_AdminUtil
+     */
+    protected function _getAdminUtil()
+    {
+        return new sspmod_janus_AdminUtil();
+    }
+}
diff --git a/modules/janus/lib/REST/Mapper/SamlMetadata.php b/modules/janus/lib/REST/Mapper/SamlMetadata.php
new file mode 100644
index 0000000..de4ece8
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/SamlMetadata.php
@@ -0,0 +1,67 @@
+<?php
+
+abstract class sspmod_janus_REST_Mapper_SamlMetadata extends sspmod_janus_REST_Mapper_Abstract
+{
+    /**
+     * @var string idp/sp saml20 type
+     */
+    protected $_samlType = 'unknown';
+
+    /**
+     * @return array
+     */
+    public function getCollection()
+    {
+        $mb = new sspmod_janus_MetadatafieldBuilder(
+            self::getConfig()->getArray('metadatafields.' . $this->_samlType)
+        );
+
+        $result = array();
+        foreach ($mb->getMetadatafields() as $field) {
+            $row = array(
+                'name'    => $field->name,
+                'type' => $field->type,
+                'default' => isset($field->default)
+                    ? $field->default : null,
+                'default_allow' => isset($field->default_allow)
+                    ? $field->default_allow : null,
+                'required' => isset($field->required)
+                    ? $field->required : null,
+                'validate' => isset($field->validate)
+                    ? $field->validate : null,
+            );
+
+            switch($field->type) {
+                case 'file':
+                    $row['filetype'] = isset($field->filetype)
+                        ? $field->filetype : null;
+                    $row['maxsize'] = isset($field->maxsize)
+                        ? $field->maxsize : null;
+                    break;
+                case 'select':
+                    $row['select_values'] = isset($field->select_values)
+                        ? $field->select_values : null;
+                    break;
+            }
+
+            $result[] = $row;
+        }
+
+        return $result;
+    }
+
+    /**
+     * @param string $id
+     * @return array
+     */
+    public function get($id)
+    {
+        foreach ($this->getCollection() as $field) {
+            if ($field['name'] === $id) {
+                return $field;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/modules/janus/lib/REST/Mapper/Sp.php b/modules/janus/lib/REST/Mapper/Sp.php
new file mode 100644
index 0000000..2c3fbd8
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/Sp.php
@@ -0,0 +1,9 @@
+<?php
+
+class sspmod_janus_REST_Mapper_Sp extends sspmod_janus_REST_Mapper_SamlEntity
+{
+    /**
+     * @var string idp/sp saml20 type
+     */
+    protected $_samlType = 'saml20-sp';
+}
diff --git a/modules/janus/lib/REST/Mapper/SpMetadata.php b/modules/janus/lib/REST/Mapper/SpMetadata.php
new file mode 100644
index 0000000..71e0b34
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/SpMetadata.php
@@ -0,0 +1,9 @@
+<?php
+
+class sspmod_janus_REST_Mapper_SpMetadata extends sspmod_janus_REST_Mapper_SamlMetadata
+{
+    /**
+     * @var string idp/sp saml20 type
+     */
+    protected $_samlType = 'saml20-sp';
+}
diff --git a/modules/janus/lib/REST/Mapper/User.php b/modules/janus/lib/REST/Mapper/User.php
new file mode 100644
index 0000000..b9a46bb
--- /dev/null
+++ b/modules/janus/lib/REST/Mapper/User.php
@@ -0,0 +1,56 @@
+<?php
+
+class sspmod_janus_REST_Mapper_User extends sspmod_janus_REST_Mapper_Abstract
+{
+    /**
+     * @return array
+     */
+    public function getCollection()
+    {
+        $result = array();
+
+        foreach (self::getUserController()->getUsers() as $user) {
+            $result[]= $this->_formatUser($user);
+        }
+
+        return $result;
+    }
+
+    /**
+     * @param string $id
+     * @return array
+     */
+    public function get($id)
+    {
+        $user = new sspmod_janus_User(
+            self::getConfig()->getValue('store')
+        );
+
+        $user->setUserid($id);
+        $result = $user->load(sspmod_janus_User::USERID_LOAD);
+
+        if ($result === false) {
+            throw new sspmod_janus_REST_Exception_NotFound(
+                sprintf('User with ID \'%s\' not found', $id)
+            );
+        }
+
+        return $this->_formatUser($user);
+    }
+
+    /**
+     * @param sspmod_janus_User $user
+     * @return array
+     */
+    protected function _formatUser(sspmod_janus_User $user)
+    {
+        $result = array();
+        $result['uid']      = $user->getUid();
+        $result['userid']   = $user->getUserid();
+        $result['active']   = $user->getActive();
+        $result['type']     = $user->getType();
+        $result['data']     = $user->getdata();
+
+        return $result;
+    }
+}
diff --git a/modules/janus/lib/REST/PermissionManager.php b/modules/janus/lib/REST/PermissionManager.php
new file mode 100644
index 0000000..9d39a68
--- /dev/null
+++ b/modules/janus/lib/REST/PermissionManager.php
@@ -0,0 +1,244 @@
+<?php
+
+class sspmod_janus_REST_PermissionManager
+{
+    /**
+     * @var sspmod_janus_REST_Request $_request
+     */
+    protected $_request = null;
+
+    /**
+     * @param sspmod_janus_REST_Request $request
+     */
+    public function __construct(sspmod_janus_REST_Request $request)
+    {
+        $this->_request = $request;
+    }
+
+    /**
+     * @param sspmod_janus_User $user
+     * @return bool true on success
+     * @throws sspmod_janus_REST_Exception_NotAuthorized
+     */
+    public function authorize(sspmod_janus_User $user)
+    {
+        // get request entity for entity-level permissions
+        $targetEntity = $this->_request->getTargetEntity();
+
+        // see if anything is allowed based on user roles
+        foreach ((array)$user->getType() as $type) {
+            switch ($type) {
+                case 'rest-admin':
+                    return true;
+                case 'rest-proxy':
+                    if ($this->_request->isGet()) {
+                        return true;
+                    }
+                    break;
+                case 'rest-idp-admin':
+                    if ($targetEntity['name'] === 'idp') {
+                        return true;
+                    }
+                    break;
+                case 'rest-sp-admin':
+                    if ($targetEntity['name'] === 'sp') {
+                        return true;
+                    }
+                    break;
+                case 'rest-sp':
+                    if (
+                        ($targetEntity['name'] === 'sp') &&
+                        ($this->_isAllowedForEntity($user, $targetEntity))
+                    ) {
+                        return true;
+                    }
+                    break;
+                case 'rest-idp':
+                    if (
+                        ($targetEntity['name'] === 'idp') &&
+                        ($this->_isAllowedForEntity($user, $targetEntity))
+                    ) {
+                        return true;
+                    }
+                    break;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Create user from authorization header
+     *
+     * @return \sspmod_janus_User
+     * @throws sspmod_janus_REST_Exception_NotAuthorized
+     */
+    public function authenticate()
+    {
+        list($username, $password) = $this->_parseAuthorizationHeader();
+
+        $user = new sspmod_janus_User(
+            SimpleSAML_Configuration::getConfig('module_janus.php')->getValue('store')
+        );
+        $user->setUserid($username);
+
+        $controller = sspmod_janus_REST_Mapper_Abstract::getUserController();
+        $controller->setUser($user);
+
+        // load user
+        if(!$user->load(sspmod_janus_User::USERID_LOAD)) {
+            throw new sspmod_janus_REST_Exception_NotAuthorized(
+                'User not found'
+            );
+        }
+
+        // load allowed entities
+        $controller->getEntities();
+
+        // check active flag
+        if ($user->getActive() !== 'yes') {
+            throw new sspmod_janus_REST_Exception_NotAuthorized(
+                'User is not active'
+            );
+        }
+
+        // check password
+        $salt     = $this->_getConfigValue('authentication-salt');
+
+        //! @todo implement hashing of password (janus gui)
+//        $checkSum = sha256($salt . $password);
+        $checkSum = $password;
+
+        if ($user->getSecret() !== $checkSum) {
+            throw new sspmod_janus_REST_Exception_NotAuthorized(
+                'User password mismatch'
+            );
+        }
+
+        return $user;
+    }
+
+    /**
+     * Returns true if the user has any of the provided roles
+     * 
+     * @param sspmod_janus_User $user
+     * @param array $roles
+     * @return boolean
+     */
+    public function hasRole(sspmod_janus_User $user, $roles)
+    {
+        foreach ((array)$user->getType() as $role) {
+            if (in_array($role, (array)$roles)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * @param sspmod_janus_User $user
+     * @param string $name
+     * @return bool
+     * @throws sspmod_janus_REST_Exception_NotAuthorized
+     */
+    public function hasFieldPermissions(sspmod_janus_User $user, $name)
+    {
+        if ($this->hasRole($user, 'rest-admin')) {
+            return true;
+        }
+
+        if ($name === 'arp') {
+            return $this->hasRole($user, 'rest-arp');
+        }
+
+        if ($name === 'blocked') {
+            return $this->hasRole($user, 'rest-blocked');
+        }
+
+        if ($name === 'allowed') {
+            return $this->hasRole($user, 'rest-allowed');
+        }
+
+        return true;
+    }
+
+    /**
+     * Create user from authorization header
+     *
+     * @return array (username, password)
+     * @throws sspmod_janus_REST_Exception_NotAuthorized
+     */
+    protected function _parseAuthorizationHeader()
+    {
+        $header = $this->_request->getHeader('Authorization');
+        if (!$header) {
+            $this->_response->addHeader('WWW-Authenticate', sprintf(
+                'Basic realm="%s"', $this->_getConfigValue('authentication-realm')
+            ));
+
+            throw new sspmod_janus_REST_Exception_NotAuthorized(
+                'Missing Authorization header'
+            );
+        }
+
+        // parse header
+        if (!preg_match('#Basic (.+)#', $header, $matches)) {
+            throw new sspmod_janus_REST_Exception_NotAuthorized(
+                'Authorization header must match "Basic [base64 encoded username:password]"'
+            );
+        }
+
+        $decoded  = explode(':', base64_decode($matches[1]));
+        $password = array_pop($decoded);
+
+        if (count($decoded) === 0) {
+            throw new sspmod_janus_REST_Exception_NotAuthorized(
+                'Error parsing Authorization header'
+            );
+        }
+
+        return array(
+            implode(':', $decoded),
+            $password
+        );
+    }
+
+    /**
+     * @param \sspmod_janus_User $user
+     * @param array $entity
+     */
+    protected function _isAllowedForEntity(sspmod_janus_User $user, array $target)
+    {
+        if ($this->hasRole($user, array('rest-admin', 'rest-sp-admin', 'rest-idp-admin'))) {
+            return true;
+        }
+
+        // on collections, allow list only
+        if (empty($target['id'])) {
+            return $this->_request->isGet();
+        }
+
+        $controller = sspmod_janus_REST_Mapper_Abstract::getUserController();
+        foreach ($controller->getEntities() as $entity) {
+            if ($entity->getEid() === $target['id']) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns API config value
+     *
+     * @param string $name
+     * @return mixed
+     */
+    protected function _getConfigValue($name)
+    {
+        return SimpleSAML_Configuration::getConfig('module_janus.php')
+            ->getConfigItem('rest-api')
+            ->getValue($name);
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/REST/Request.php b/modules/janus/lib/REST/Request.php
index 8c17a84..d2fa307 100644
--- a/modules/janus/lib/REST/Request.php
+++ b/modules/janus/lib/REST/Request.php
@@ -1,62 +1,248 @@
 <?php
+
 class sspmod_janus_REST_Request
 {
-    // Params from request (DIRTY)
-    private $_raw_data = array();
-    private $_request_vars = array();
-    private $_signature = null;
-    private $_key = null;
-    private $_method = null;
+    /**
+     * Supported HTTP methods (can be limited by the
+     *  requested resource)
+     */
+    const METHOD_GET    = 'GET';
+    const METHOD_PUT    = 'PUT';
+    const METHOD_POST   = 'POST';
+    const METHOD_DELETE = 'DELETE';
+    const METHOD_HEAD   = 'HEAD';
+    const METHOD_TRACE  = 'TRACE';
+
+    /**
+     * @var string $_method
+     */
+    protected $_method = null;
+
+    /**
+     * @var string $_resource
+     */
+    protected $_resource = null;
 
-    public function __construct() {}
+    /**
+     * @var array $_parameters
+     */
+    protected $_parameters = array();
 
-    public function setRawdata($data)
+    /**
+     * @param string $method HTTP method
+     * @param string $resource Entity ID
+     * @param array $request Copy of request superglobal
+     */
+    public function __construct($method, $resource, array $parameters)
     {
-        $this->_raw_data = $data;
+        $this->_method     = (string)$method;
+        $this->_resource   = (string)$resource;
+        $this->_parameters = $parameters;
     }
 
-    public function getRawdata()
+    /**
+     * Returns HTTP method (see defined class constants)
+     *
+     * @return string
+     */
+    public function getMethod()
     {
-        return $this->_raw_data;
+        // always use uppercase method names
+        $method = strtoupper($this->_method);
+
+        // throw exception on invalid method
+        $reflection = new ReflectionObject($this);
+        if (!$reflection->hasConstant('METHOD_' . $method)) {
+            throw new sspmod_janus_REST_Exception_NotImplemented(
+                'This API does not support the requested method'
+            );
     }
 
-    public function setSignature($signature)
+        return $method;
+    }
+
+    /**
+     * @return bool
+     */
+    public function isGet()
     {
-        $this->_signature = $signature;
+        return $this->getMethod() === self::METHOD_GET;
     }
 
-    public function getSignature()
+    /**
+     * @return bool
+     */
+    public function isPut()
     {
-        return $this->_signature;
+        return $this->getMethod() === self::METHOD_PUT;
     }
 
-    public function setKey($key)
+    /**
+     * Returns the request params (assumed copy of request superglobal)
+     *
+     * @return array
+     */
+    public function getParameters()
     {
-        $this->_key = $key;
+        return $this->_parameters;
     }
 
-    public function getKey()
+    /**
+     * Returns one request parameter
+     *
+     * @param string $name
+     * @param mixed $default
+     * @return mixed
+     */
+    public function getParameter($name, $default = null)
     {
-        return $this->_key;
+        return (isset($this->_parameters[$name]))
+            ? $this->_parameters[$name]
+            : $default;
     }
 
-    public function setMethod($method)
+    /**
+     * Returns one request header
+     *
+     * @param string $name
+     * @return mixed
+     */
+    public function getHeader($name)
     {
-        $this->_method = $method;
+        $headers = $this->getHeaders();
+
+        return isset($headers[$name]) ? $headers[$name] : null;
     }
 
-    public function getMethod()
+    /**
+     * Returns all request headers
+     *
+     * @return array
+     */
+    public function getHeaders()
     {
-        return $this->_method;
+        $headers = apache_request_headers();
+
+        // should happen when not running on apache
+        if (empty($headers)) {
+            throw new sspmod_janus_REST_Exception_InternalServerError(
+                'Unable to read request headers, please add support '
+                . 'for non-apache web servers.'
+            );
+        }
+
+        return $headers;
+    }
+
+    /**
+     * Set one request parameter
+     *
+     * @param string $name
+     * @param mixed $value
+     * @return sspmod_janus_REST_Request
+     */
+    public function setParameter($name, $value)
+    {
+        $this->_parameters[$name] = $value;
+
+        return $this;
     }
 
-    public function setRequestVars($request_vars)
+    /**
+     * Parses request bodies
+     *
+     * @return \sspmod_janus_REST_Request
+     * @throws sspmod_janus_REST_Exception_BadRequest
+     */
+    public function initParameters()
     {
-        $this->_request_vars = $request_vars;
+        // try to parse request body
+        $body = file_get_contents('php://input');
+        if ($body) {
+            $decoded = json_decode($body);
+            if (!$decoded) {
+                throw new sspmod_janus_REST_Exception_BadRequest(
+                    'Non-JSON request body detected'
+                );
+            }
+
+            $this->_parameters = array_merge(
+                $this->_parameters, (array)$decoded
+            );
+        }
+
+        return $this;
+    }
+
+    /**
+     * Test existence of parameter
+     *
+     * @param string $name
+     * @param mixed $default
+     * @return mixed
+     */
+    public function hasParameter($name)
+    {
+        return (array_key_exists($name, $this->_parameters));
+    }
+
+    /**
+     * Collection request? /idp or /idp/5/arp
+     *
+     * @return bool
+     */
+    public function isCollection()
+    {
+        $parts = $this->getTargetEntity();
+
+        return empty($parts['id']);
+    }
+
+    /**
+     * Has target entity?
+     *  false: /
+     *  true:  /idp
+     *
+     * @return bool
+     */
+    public function hasTargetEntity()
+    {
+        $parts = $this->getTargetEntity();
+
+        return !empty($parts['name']);
+    }
+
+    /**
+     * We support no nesting, return entity name and if
+     * of URI
+     *
+     * @return array
+     */
+    public function getTargetEntity()
+    {
+        $resource = trim($this->_resource, '/');
+
+        $parts = explode('/', $resource, 2);
+
+        return array(
+            'name' => isset($parts[0])
+                ? $parts[0] : null,
+            'id' => isset($parts[1])
+                ? $parts[1] : null,
+        );
     }
 
-    public function getRequestVars()
+    /**
+     * Send message to Logger
+     */
+    public function logRequest()
     {
-        return $this->_request_vars;
+        SimpleSAML_Logger::error(sprintf(
+            'Handling %s %s [PARAMS: \'%s\'] [HEADERS: \'%s\']',
+            $this->getMethod(),
+            $this->_resource,
+            var_export($this->getParameters(), true),
+            var_export($this->getHeaders(), true)
+        ));
     }
 }
diff --git a/modules/janus/lib/REST/Response.php b/modules/janus/lib/REST/Response.php
new file mode 100644
index 0000000..e52b834
--- /dev/null
+++ b/modules/janus/lib/REST/Response.php
@@ -0,0 +1,154 @@
+<?php
+
+class sspmod_janus_REST_Response
+{
+    /**
+     * @var array $_data
+     */
+    protected $_data = null;
+
+    /**
+     * @var array $_headers
+     */
+    protected $_headers = null;
+
+    /**
+     * @var int $_httpCode
+     */
+    protected $_httpCode = null;
+
+    /**
+     * @var string $_httpMessage
+     */
+    protected $_httpMessage = null;
+
+    /**
+     * @param array $data
+     * @param int $httpCode
+     * @param string $httpMessage
+     */
+    public function __construct(array $data = array(), array $headers = array(),
+        $httpCode = 200, $httpMessage = 'OK')
+    {
+        $this->_data        = $data;
+        $this->_headers     = $headers;
+        $this->_httpCode    = (int)$httpCode;
+        $this->_httpMessage = (string)$httpMessage;
+    }
+
+    /**
+     * @param array $data Response data
+     * @return sspmod_janus_REST_Response
+     */
+    public function setData(array $data)
+    {
+        $this->_data = $data;
+
+        return $this;
+    }
+
+    /**
+     * @param int $httpCode
+     * @param string $httpMessage
+     * @return sspmod_janus_REST_Response
+     */
+    public function setHttpStatus($httpCode, $httpMessage)
+    {
+        $this->_httpCode    = (int)$httpCode;
+        $this->_httpMessage = (string)$httpMessage;
+
+        return $this;
+    }
+
+    /**
+     * @param Exception|sspmod_janus_REST_HttpError $fault
+     * @return sspmod_janus_REST_Response
+     */
+    public function setError(Exception $fault)
+    {
+        $classParts = explode('_', get_class($fault));
+        $this->setData(
+            array(
+                'error'    => array_pop($classParts),
+                'message'  => $fault->getMessage(),
+            )
+        );
+
+        // default to HTTP 500 on generic exceptions
+        $this->setHttpStatus(
+            500, 'Internal Server Error'
+        );
+
+        // set custom HTTP code when specified
+        if ($fault instanceof sspmod_janus_REST_HttpError) {
+            $this->setHttpStatus(
+                $fault->getHttpErrorCode(), $fault->getHttpErrorMessage()
+            );
+        }
+
+        return $this;
+    }
+
+    /**
+     * @param $name
+     * @param $value
+     * @return sspmod_janus_REST_Response
+     */
+    public function addHeader($name, $value)
+    {
+        $this->_headers[$name] = $value;
+
+        return $this;
+    }
+
+    /**
+     * Returns json encoded response body
+     *
+     * @return string
+     */
+    public function render()
+    {
+        return json_encode(
+            $this->_data
+        );
+    }
+
+    /**
+     * Send the HTTP response
+     *
+     * @return int 1, always
+     */
+    public function send()
+    {
+        header("HTTP/1.0 {$this->_httpCode} {$this->_httpMessage}");
+
+        foreach ($this->_headers as $name => $value) {
+            header("$name: $value");
+        }
+
+        return print $this->render();
+    }
+
+    /**
+     * Proxy to render()
+     *
+     * @return string
+     */
+    public function __toString()
+    {
+        return $this->render();
+    }
+
+    /**
+     * Send message to Logger
+     */
+    public function logResponse()
+    {
+        SimpleSAML_Logger::error(sprintf(
+            'Error handling request: %s %s [BODY: \'%s\']',
+            $this->_httpCode,
+            $this->_httpMessage,
+            var_export($this->_data, true)
+        ));
+    }
+}
diff --git a/modules/janus/lib/REST/Server.php b/modules/janus/lib/REST/Server.php
new file mode 100644
index 0000000..eb6af2a
--- /dev/null
+++ b/modules/janus/lib/REST/Server.php
@@ -0,0 +1,220 @@
+<?php
+
+class sspmod_janus_REST_Server
+{
+    /**
+     * List of supported entities
+     */
+    protected $_entityTypes = array(
+         'user', 'idp', 'sp', 'idp-metadata', 'sp-metadata', 'arp',
+    );
+
+    /**
+     * @var sspmod_janus_REST_Request $_request
+     */
+    protected $_request = null;
+
+    /**
+     * @var sspmod_janus_REST_Request $_response
+     */
+    protected $_response = null;
+
+    /**
+     * @param sspmod_janus_REST_Request $request
+     * @param sspmod_janus_REST_Response $response
+     */
+    public function __construct(
+        sspmod_janus_REST_Request $request,
+        sspmod_janus_REST_Response $response
+    ) {
+        $this->_request  = $request;
+        $this->_response = $response;
+    }
+
+    /**
+     * @return sspmod_janus_REST_Server
+     */
+    public function handle()
+    {
+        try {
+            // parse request  body
+            $this->_request->initParameters();
+
+            // log this request
+            $this->_request->logRequest();
+
+            // authenticate & authorize
+            $this->_login();
+
+            // execute request
+            $result = $this->_executeRequest();
+            if ($result) {
+                $this->_response->setData(array(
+                    'result' => $result,
+                ));
+            }
+
+        } catch (Exception $e) {
+            // set error data on response object
+            $this->_response->setError($e);
+
+            // log this error
+            $this->_response->logResponse();
+        }
+
+        return $this;
+    }
+
+    /**
+     * @param string $type
+     * @return string
+     */
+    public function isSupportedEntityType($type)
+    {
+        return in_array($type, $this->_entityTypes);
+    }
+
+    /**
+     * HTTP basic authentication
+     *
+     * @return sspmod_janus_REST_Server
+     */
+    protected function _login()
+    {
+        $manager = sspmod_janus_REST_Mapper_Abstract::getPermissionManager($this->_request);
+
+        $user = $manager->authenticate();
+
+        if (!$manager->authorize($user)) {
+            throw new sspmod_janus_REST_Exception_NotAuthorized(
+                'You are not sufficiently authorized'
+            );
+        }
+
+        return $this;
+    }
+
+    /**
+     * Call mapper and return response
+     *
+     * @return array
+     */
+    protected function _executeRequest()
+    {
+        // handle " /"
+        if (!$this->_request->hasTargetEntity()) {
+            if (!$this->_request->isGet()) {
+                throw new sspmod_janus_REST_Exception_NotImplemented(
+                    'Only GET is implemented on /'
+                );
+            }
+
+            return $this->_getRootCollectionResources();
+        }
+
+        $target = $this->_request->getTargetEntity();
+
+        // check valid id/method, return collection
+        if ($this->_request->isCollection()) {
+            $mapper = $this->_createMapper($target['name']);
+
+            // create new resource on collection
+            if ($this->_request->isPut()) {
+                return array($mapper->put());
+            }
+
+            if (!$this->_request->isGet()) {
+                throw new sspmod_janus_REST_Exception_NotImplemented(
+                    'Collections only support GET (list) or PUT (create)'
+                );
+            }
+
+            return $this->_createMapper($target['name'])
+                ->getCollection();
+        }
+
+        return array_filter(array(
+            $this->_callMapper(
+                $target, $this->_request->getMethod()
+            )
+        ));
+    }
+
+    /**
+     * @param array $target
+     * @param string $method
+     * @return sspmod_janus_Mapper
+     */
+    protected function _callMapper(array $target, $method = 'GET')
+    {
+        // create mapper
+        $mapper = $this->_createMapper($target['name']);
+
+        if (!is_callable(array($mapper, $method))) {
+            throw new sspmod_janus_REST_Exception_NotImplemented(
+                sprintf('Unsupported request method \'%s\'', $method)
+            );
+        }
+
+        if ($this->_request->isPut() && ($method !== 'GET')) {
+            throw new sspmod_janus_REST_Exception_NotImplemented(
+                'Use PUT on entity collection to create a new resource'
+            );
+        }
+
+        // get(), post(), delete(), etc
+        return $mapper->$method($target['id']);
+    }
+
+    /**
+     * @param string $type
+     * @return sspmod_janus_Mapper
+     */
+    protected function _createMapper($type)
+    {
+        if (!$this->isSupportedEntityType($type)) {
+            throw new sspmod_janus_REST_Exception_NotFound(
+                sprintf('Unknown entity type \'%s\'', $type)
+            );
+        }
+
+        $casedType = '';
+        foreach (explode('-', $type) as $part) {
+            $casedType .= ucfirst($part);
+        }
+
+        $className = 'sspmod_janus_REST_Mapper_' . $casedType;
+        if (!class_exists($className)) {
+            throw new sspmod_janus_REST_Exception(
+                'Bad configuration for entity type (missing mapper)'
+            );
+        }
+
+        return new $className(
+            $this->_request, $this->_response
+        );
+    }
+
+    /**
+     * @return array all available collections
+     */
+    protected function _getRootCollectionResources()
+    {
+        return array(
+            '/idp', '/sp', '/arp', '/sp-metadata', 'idp-metadata'
+        );
+    }
+
+    /**
+     * Returns API config value
+     *
+     * @param string $name
+     * @return mixed
+     */
+    protected function _getConfigValue($name)
+    {
+        return SimpleSAML_Configuration::getConfig('module_janus.php')
+            ->getConfigItem('rest-api')
+            ->getValue($name);
+    }
+}
\ No newline at end of file
diff --git a/modules/janus/lib/User.php b/modules/janus/lib/User.php
index a1ffec4..102e5e9 100644
--- a/modules/janus/lib/User.php
+++ b/modules/janus/lib/User.php
@@ -147,16 +147,18 @@ class sspmod_janus_User extends sspmod_janus_Database
                 (`uid`, 
                 `userid`, 
                 `type`, 
+                `secret`,
                 `email`, 
                 `active`, 
                 `update`, 
                 `created`, 
                 `ip`) 
                 VALUES 
-                (null, ?, ?, ?, ?, ?, ?, ?)',
+                (null, ?, ?, ?, ?, ?, ?, ?, ?)',
                 array(
                     $this->_userid,
                     serialize($this->_type),
+                    $this->_secret,
                     $this->_email,
                     $this->_active,
                     date('c'),
diff --git a/modules/janus/templates/dashboard.php b/modules/janus/templates/dashboard.php
index f7f304b..f57ff93 100644
--- a/modules/janus/templates/dashboard.php
+++ b/modules/janus/templates/dashboard.php
@@ -783,6 +783,10 @@ if($this->data['uiguard']->hasPermission('admintab', null, $this->data['user']->
                                     <td><input type="text" name="userid" value="" size="20" /></td>
                                 </tr>
                                 <tr>
+                                    <td><?php echo $this->t('admin_rest_secret'); ?>:</td>
+                                    <td><input type="text" name="secret" value="" /></td>
+                                </tr>
+                                <tr>
                                     <td><?php echo $this->t('tab_user_data_otherinfo');  ?>:</td>
                                     <td><textarea name="userdata" cols="100" rows="3"></textarea></td>
                                 </tr>
diff --git a/modules/janus/www/dashboard.php b/modules/janus/www/dashboard.php
index a22f033..aa2e53c 100644
--- a/modules/janus/www/dashboard.php
+++ b/modules/janus/www/dashboard.php
@@ -68,6 +68,7 @@ if(isset($_POST['add_usersubmit'])) {
             $new_user = new sspmod_janus_User($janus_config->getValue('store'));
             $new_user->setUserid($_POST['userid']);
             $new_user->setType($_POST['type']);
+            $new_user->setSecret($_POST['secret']);
             if(isset($_POST['active']) && $_POST['active'] == 'on') {
                 $active = 'yes';
             } else {
diff --git a/modules/janus/www/services/rest-v2/index.php b/modules/janus/www/services/rest-v2/index.php
new file mode 100644
index 0000000..c35ff54
--- /dev/null
+++ b/modules/janus/www/services/rest-v2/index.php
@@ -0,0 +1,48 @@
+<?php
+/*
+ * REST v2 SERVICE ENDPOINT
+ *
+ * Supported URL formats, rest-full URI's:
+ *  module.php/janus/services/rest-v2/entity
+ *  module.php/janus/services/rest-v2/entity?id=314
+ *
+ * URI by query parameter:
+ *  module.php/janus/services/rest-v2/index.php?uri=/entity
+ *  module.php/janus/services/rest-v2/index.php?uri=/entity&id=314
+ */
+
+// load configuration file
+$config = SimpleSAML_Configuration::getConfig('module_janus.php')
+    ->getConfigItem('rest-api');
+
+// set path info if traling slash is omitted on root
+if (!isset($_SERVER['PATH_INFO'])) {
+    $_SERVER['PATH_INFO'] = '/';
+}
+
+// support legacy URLs (URI by query parameter e.g. /rest-v2/?uri=/entities)
+if (($_SERVER['PATH_INFO'] === '/') && (!empty($_REQUEST['uri']))) {
+    $_SERVER['PATH_INFO'] = $_REQUEST['uri'];
+}
+
+// create request object
+$request = new sspmod_janus_REST_Request(
+    $_SERVER['REQUEST_METHOD'], $_SERVER['PATH_INFO'], $_REQUEST
+);
+
+// create response object
+$response = new sspmod_janus_REST_Response();
+$response->addHeader(
+    'Content-Type', $config->getValue('vendor-mime-type')
+);
+
+// create Server instance
+$server = new sspmod_janus_REST_Server(
+    $request, $response
+);
+
+// execute request
+$server->handle();
+
+// send response headers and body
+$response->send();
diff --git a/modules/janus/www/services/rest/index.php b/modules/janus/www/services/rest/index.php
index 54db846..eb57f4c 100644
--- a/modules/janus/www/services/rest/index.php
+++ b/modules/janus/www/services/rest/index.php
@@ -1,9 +1,17 @@
 <?php
-$request = sspmod_janus_REST_Utils::processRequest($_GET);
+/**
+ * This REST endpoint is deprecated, please use the 'rest-v2' endpoint.
+ *
+ * All source code beloging to the old REST endpoint is contained in the
+ * 'Legacy' namespace.
+ *
+ * @deprecated by the v2 REST endpoint
+ */
+$request = sspmod_janus_REST_Legacy_Utils::processRequest($_GET);
 
 if (is_object($request)) {
-    $result = sspmod_janus_REST_Utils::callMethod($request);
-    sspmod_janus_REST_Utils::sendResponse($result['status'], $result['data'], 'application/json');
+    $result = sspmod_janus_REST_Legacy_Utils::callMethod($request);
+    sspmod_janus_REST_Legacy_Utils::sendResponse($result['status'], $result['data'], 'application/json');
 } else {
     throw new Exception('Could not process Janus REST request');
 }
\ No newline at end of file
diff --git a/tests/jmeter/DefaultTest.php b/tests/jmeter/DefaultTest.php
new file mode 100644
index 0000000..922c926
--- /dev/null
+++ b/tests/jmeter/DefaultTest.php
@@ -0,0 +1,9 @@
+<?php
+
+class DefaultTestCase extends PHPUnit_Framework_TestCase
+{
+    public function testNothing()
+    {
+        $this->assertTrue(true, "All is right with the universe");
+    }
+}
diff --git a/tests/jmeter/janus-v2-json-rest-api.jmx b/tests/jmeter/janus-v2-json-rest-api.jmx
new file mode 100644
index 0000000..0e26f8f
--- /dev/null
+++ b/tests/jmeter/janus-v2-json-rest-api.jmx
@@ -0,0 +1,2089 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<jmeterTestPlan version="1.2" properties="2.1">
+  <hashTree>
+    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="JANUS v2 JSON-REST API" enabled="true">
+      <stringProp name="TestPlan.comments"></stringProp>
+      <boolProp name="TestPlan.functional_mode">false</boolProp>
+      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
+      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+        <collectionProp name="Arguments.arguments"/>
+      </elementProp>
+      <stringProp name="TestPlan.user_define_classpath"></stringProp>
+    </TestPlan>
+    <hashTree>
+      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="Environment Settings" enabled="true">
+        <collectionProp name="Arguments.arguments">
+          <elementProp name="base_path" elementType="Argument">
+            <stringProp name="Argument.name">base_path</stringProp>
+            <stringProp name="Argument.value">/simplesaml/module.php/janus/services/rest-v2</stringProp>
+            <stringProp name="Argument.metadata">=</stringProp>
+          </elementProp>
+          <elementProp name="host" elementType="Argument">
+            <stringProp name="Argument.name">host</stringProp>
+            <stringProp name="Argument.value">serviceregistry.demo.openconext.org</stringProp>
+            <stringProp name="Argument.metadata">=</stringProp>
+          </elementProp>
+          <elementProp name="protocol" elementType="Argument">
+            <stringProp name="Argument.name">protocol</stringProp>
+            <stringProp name="Argument.value">https</stringProp>
+            <stringProp name="Argument.metadata">=</stringProp>
+          </elementProp>
+          <elementProp name="username" elementType="Argument">
+            <stringProp name="Argument.name">username</stringProp>
+            <stringProp name="Argument.value">test</stringProp>
+            <stringProp name="Argument.metadata">=</stringProp>
+          </elementProp>
+          <elementProp name="password" elementType="Argument">
+            <stringProp name="Argument.name">password</stringProp>
+            <stringProp name="Argument.value">test</stringProp>
+            <stringProp name="Argument.metadata">=</stringProp>
+          </elementProp>
+        </collectionProp>
+      </Arguments>
+      <hashTree/>
+      <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
+        <collectionProp name="HeaderManager.headers">
+          <elementProp name="" elementType="Header">
+            <stringProp name="Header.name">Content-Type</stringProp>
+            <stringProp name="Header.value">application/vnd.surfnet.nl-v2+json</stringProp>
+          </elementProp>
+          <elementProp name="" elementType="Header">
+            <stringProp name="Header.name">Authorization</stringProp>
+            <stringProp name="Header.value">Basic ${__javaScript(vars.getObject(&apos;base64&apos;).encode(vars.get(&quot;username&quot;) + &quot;:&quot; + vars.get(&quot;password&quot;)))}</stringProp>
+          </elementProp>
+        </collectionProp>
+      </HeaderManager>
+      <hashTree/>
+      <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
+        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+          <collectionProp name="Arguments.arguments"/>
+        </elementProp>
+        <stringProp name="HTTPSampler.domain">${host}</stringProp>
+        <stringProp name="HTTPSampler.port"></stringProp>
+        <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+        <stringProp name="HTTPSampler.response_timeout"></stringProp>
+        <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
+        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+        <stringProp name="HTTPSampler.path"></stringProp>
+        <stringProp name="HTTPSampler.implementation">HttpClient3.1</stringProp>
+        <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
+      </ConfigTestElement>
+      <hashTree/>
+      <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="JSON encoder" enabled="true">
+        <stringProp name="scriptLanguage">javascript</stringProp>
+        <stringProp name="parameters"></stringProp>
+        <stringProp name="filename"></stringProp>
+        <stringProp name="script">/*
+ usage: vars.getObject(&apos;json&apos;).encode(object)
+*/
+
+/* http://www.hardcode.nl/subcategory_1/article_364-tojson-function.htm */
+vars.putObject(&apos;json&apos;, {encode:function(obj){
+ var encode_json = vars.getObject(&apos;json&apos;).encode;
+ switch (typeof obj) {
+  case &apos;object&apos;:
+   if (obj) {
+    var list = [];
+    if (obj instanceof Array) {
+     for (var i=0;i &lt; obj.length;i++) {
+      list.push(encode_json(obj[i]));
+     }
+     return &apos;[&apos; + list.join(&apos;,&apos;) + &apos;]&apos;;
+    } else {
+     for (var prop in obj) {
+      list.push(&apos;&quot;&apos; + prop + &apos;&quot;:&apos; + encode_json(obj[prop]));
+     }
+     return &apos;{&apos; + list.join(&apos;,&apos;) + &apos;}&apos;;
+    }
+   } else {
+    return &apos;null&apos;;
+   }
+  case &apos;string&apos;:
+   return &apos;&quot;&apos; + obj.replace(/([&quot;&apos;])/g, &apos;\\$1&apos;) + &apos;&quot;&apos;;
+  case &apos;number&apos;:
+  case &apos;boolean&apos;:
+   return new String(obj);
+ }
+}});
+</stringProp>
+      </BSFPreProcessor>
+      <hashTree/>
+      <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Base64 encoder" enabled="true">
+        <stringProp name="scriptLanguage">javascript</stringProp>
+        <stringProp name="parameters"></stringProp>
+        <stringProp name="filename"></stringProp>
+        <stringProp name="script">/*
+ usage: vars.getObject(&apos;base64&apos;).encode(object)
+*/
+
+/**
+*
+*  Base64 encode / decode
+*  http://www.webtoolkit.info/
+*
+**/ 
+var Base64 = {
+ 
+	// private property
+	_keyStr : &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;,
+ 
+	// public method for encoding
+	encode : function (input) {
+		var output = &quot;&quot;;
+		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
+		var i = 0;
+ 
+		input = Base64._utf8_encode(input);
+ 
+		while (i &lt; input.length) {
+ 
+			chr1 = input.charCodeAt(i++);
+			chr2 = input.charCodeAt(i++);
+			chr3 = input.charCodeAt(i++);
+ 
+			enc1 = chr1 &gt;&gt; 2;
+			enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
+			enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6);
+			enc4 = chr3 &amp; 63;
+ 
+			if (isNaN(chr2)) {
+				enc3 = enc4 = 64;
+			} else if (isNaN(chr3)) {
+				enc4 = 64;
+			}
+ 
+			output = output +
+			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
+			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
+ 
+		}
+ 
+		return output;
+	},
+ 
+	// public method for decoding
+	decode : function (input) {
+		var output = &quot;&quot;;
+		var chr1, chr2, chr3;
+		var enc1, enc2, enc3, enc4;
+		var i = 0;
+ 
+		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, &quot;&quot;);
+ 
+		while (i &lt; input.length) {
+ 
+			enc1 = this._keyStr.indexOf(input.charAt(i++));
+			enc2 = this._keyStr.indexOf(input.charAt(i++));
+			enc3 = this._keyStr.indexOf(input.charAt(i++));
+			enc4 = this._keyStr.indexOf(input.charAt(i++));
+ 
+			chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
+			chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
+			chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;
+ 
+			output = output + String.fromCharCode(chr1);
+ 
+			if (enc3 != 64) {
+				output = output + String.fromCharCode(chr2);
+			}
+			if (enc4 != 64) {
+				output = output + String.fromCharCode(chr3);
+			}
+ 
+		}
+ 
+		output = Base64._utf8_decode(output);
+ 
+		return output;
+ 
+	},
+ 
+	// private method for UTF-8 encoding
+	_utf8_encode : function (string) {
+		string = string.replace(/\r\n/g,&quot;\n&quot;);
+		var utftext = &quot;&quot;;
+ 
+		for (var n = 0; n &lt; string.length; n++) {
+ 
+			var c = string.charCodeAt(n);
+ 
+			if (c &lt; 128) {
+				utftext += String.fromCharCode(c);
+			}
+			else if((c &gt; 127) &amp;&amp; (c &lt; 2048)) {
+				utftext += String.fromCharCode((c &gt;&gt; 6) | 192);
+				utftext += String.fromCharCode((c &amp; 63) | 128);
+			}
+			else {
+				utftext += String.fromCharCode((c &gt;&gt; 12) | 224);
+				utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128);
+				utftext += String.fromCharCode((c &amp; 63) | 128);
+			}
+ 
+		}
+ 
+		return utftext;
+	},
+ 
+	// private method for UTF-8 decoding
+	_utf8_decode : function (utftext) {
+		var string = &quot;&quot;;
+		var i = 0;
+		var c = c1 = c2 = 0;
+ 
+		while ( i &lt; utftext.length ) {
+ 
+			c = utftext.charCodeAt(i);
+ 
+			if (c &lt; 128) {
+				string += String.fromCharCode(c);
+				i++;
+			}
+			else if((c &gt; 191) &amp;&amp; (c &lt; 224)) {
+				c2 = utftext.charCodeAt(i+1);
+				string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63));
+				i += 2;
+			}
+			else {
+				c2 = utftext.charCodeAt(i+1);
+				c3 = utftext.charCodeAt(i+2);
+				string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63));
+				i += 3;
+			}
+ 
+		}
+ 
+		return string;
+	}
+};
+
+vars.putObject(&apos;base64&apos;, Base64);</stringProp>
+      </BSFPreProcessor>
+      <hashTree/>
+      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group" enabled="true">
+        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
+        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
+          <boolProp name="LoopController.continue_forever">false</boolProp>
+          <stringProp name="LoopController.loops">1</stringProp>
+        </elementProp>
+        <stringProp name="ThreadGroup.num_threads">1</stringProp>
+        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
+        <longProp name="ThreadGroup.start_time">1353414463000</longProp>
+        <longProp name="ThreadGroup.end_time">1353414463000</longProp>
+        <boolProp name="ThreadGroup.scheduler">false</boolProp>
+        <stringProp name="ThreadGroup.duration"></stringProp>
+        <stringProp name="ThreadGroup.delay"></stringProp>
+      </ThreadGroup>
+      <hashTree>
+        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname=" Test not-found errors" enabled="true">
+          <boolProp name="TransactionController.parent">true</boolProp>
+          <boolProp name="TransactionController.includeTimers">false</boolProp>
+        </TransactionController>
+        <hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{GET /bogus}" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/bogus</stringProp>
+            <stringProp name="HTTPSampler.method">GET</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 404" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="51512">404</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+          </hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{GET /idp/:bogus}" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/idp/99999</stringProp>
+            <stringProp name="HTTPSampler.method">GET</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 404" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="51512">404</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+          </hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{DELETE /idp/:bogus}" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/idp/99999</stringProp>
+            <stringProp name="HTTPSampler.method">DELETE</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 404" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="51512">404</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+          </hashTree>
+        </hashTree>
+        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname=" Test not-implemented errors" enabled="true">
+          <boolProp name="TransactionController.parent">true</boolProp>
+          <boolProp name="TransactionController.includeTimers">false</boolProp>
+        </TransactionController>
+        <hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{PUT /}" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/</stringProp>
+            <stringProp name="HTTPSampler.method">PUT</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 501" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="52470">501</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+          </hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{DELETE /idp}" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/idp</stringProp>
+            <stringProp name="HTTPSampler.method">DELETE</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 501" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="52470">501</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+          </hashTree>
+        </hashTree>
+        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname=" Test bad-request errors" enabled="true">
+          <boolProp name="TransactionController.parent">true</boolProp>
+          <boolProp name="TransactionController.includeTimers">false</boolProp>
+        </TransactionController>
+        <hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{PUT /sp} Create SP without entitiyid" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments">
+                <elementProp name="" elementType="HTTPArgument">
+                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                  <stringProp name="Argument.value">${request}</stringProp>
+                  <stringProp name="Argument.metadata">=</stringProp>
+                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
+                </elementProp>
+              </collectionProp>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/sp</stringProp>
+            <stringProp name="HTTPSampler.method">PUT</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+              <stringProp name="scriptLanguage">javascript</stringProp>
+              <stringProp name="parameters"></stringProp>
+              <stringProp name="filename"></stringProp>
+              <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({}));
+
+</stringProp>
+            </BSFPreProcessor>
+            <hashTree/>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 400" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="51508">400</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+          </hashTree>
+        </hashTree>
+        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname=" Test not-authorized errors" enabled="true">
+          <boolProp name="TransactionController.parent">true</boolProp>
+          <boolProp name="TransactionController.includeTimers">false</boolProp>
+        </TransactionController>
+        <hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{GET /} All OK" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/</stringProp>
+            <stringProp name="HTTPSampler.method">GET</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 200" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="49586">200</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+          </hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{GET /} Bad username" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/</stringProp>
+            <stringProp name="HTTPSampler.method">GET</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 401" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="51509">401</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+            <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set bogus username" enabled="true">
+              <stringProp name="scriptLanguage">javascript</stringProp>
+              <stringProp name="parameters"></stringProp>
+              <stringProp name="filename"></stringProp>
+              <stringProp name="script">vars.put(&apos;old_username&apos;, vars.get(&apos;username&apos;));
+vars.put(&apos;username&apos;, &apos;bogus&apos;);</stringProp>
+            </BSFPreProcessor>
+            <hashTree/>
+            <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Reset username" enabled="true">
+              <stringProp name="scriptLanguage">javascript</stringProp>
+              <stringProp name="parameters"></stringProp>
+              <stringProp name="filename"></stringProp>
+              <stringProp name="script">vars.put(&apos;username&apos;, vars.get(&apos;old_username&apos;));
+</stringProp>
+            </BSFPostProcessor>
+            <hashTree/>
+          </hashTree>
+          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="{GET /} Bad password" enabled="true">
+            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+              <collectionProp name="Arguments.arguments"/>
+            </elementProp>
+            <stringProp name="HTTPSampler.domain"></stringProp>
+            <stringProp name="HTTPSampler.port"></stringProp>
+            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+            <stringProp name="HTTPSampler.response_timeout"></stringProp>
+            <stringProp name="HTTPSampler.protocol"></stringProp>
+            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+            <stringProp name="HTTPSampler.path">${base_path}/</stringProp>
+            <stringProp name="HTTPSampler.method">GET</stringProp>
+            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+            <boolProp name="HTTPSampler.monitor">false</boolProp>
+            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+          </HTTPSamplerProxy>
+          <hashTree>
+            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="HTTP 401" enabled="true">
+              <collectionProp name="Asserion.test_strings">
+                <stringProp name="51509">401</stringProp>
+              </collectionProp>
+              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+              <boolProp name="Assertion.assume_success">true</boolProp>
+              <intProp name="Assertion.test_type">8</intProp>
+            </ResponseAssertion>
+            <hashTree/>
+            <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set bogus password" enabled="true">
+              <stringProp name="scriptLanguage">javascript</stringProp>
+              <stringProp name="parameters"></stringProp>
+              <stringProp name="filename"></stringProp>
+              <stringProp name="script">vars.put(&apos;old_password&apos;, vars.get(&apos;password&apos;));
+vars.put(&apos;password&apos;, &apos;bogus&apos;);</stringProp>
+            </BSFPreProcessor>
+            <hashTree/>
+            <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Reset password" enabled="true">
+              <stringProp name="scriptLanguage">javascript</stringProp>
+              <stringProp name="parameters"></stringProp>
+              <stringProp name="filename"></stringProp>
+              <stringProp name="script">vars.put(&apos;password&apos;, vars.get(&apos;old_password&apos;));
+</stringProp>
+            </BSFPostProcessor>
+            <hashTree/>
+          </hashTree>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="List available collections" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree/>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="List ARP entries" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/arp</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Response Assertions" enabled="true">
+            <stringProp name="filename"></stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+if (resp.result.length === 0) {
+  AssertionResult.setFailureMessage(&quot;No ARP entries found&quot;); 
+  AssertionResult.setFailure(true);
+}
+</stringProp>
+            <stringProp name="scriptLanguage">javascript</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Parse ARP ID" enabled="true">
+            <stringProp name="filename"></stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+vars.put(&apos;arp_id&apos;, resp.result[0].aid);
+
+</stringProp>
+            <stringProp name="scriptLanguage">javascript</stringProp>
+          </BSFPostProcessor>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="List SP metadata definitions" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp-metadata</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree/>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="List IDP metadata definitions" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp-metadata</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree/>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="List users" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/user</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertions (BSF)" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;No results returned&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Retrieve user" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/user/admin</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="1853652533">&quot;userid&quot;:&quot;admin&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Service Provider collection" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on result length" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (typeof resp.result.length === &quot;undefined&quot;) {
+  fail(&quot;No result found in object&quot;);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;Got empty result set&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Identity Provider collection" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp/</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on result length" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (typeof resp.result.length === &quot;undefined&quot;) {
+  fail(&quot;No result found in object&quot;);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;Got empty result set&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Create new Service Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp</stringProp>
+          <stringProp name="HTTPSampler.method">PUT</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+      &quot;entityid&quot;: &quot;https://test-sp-1&quot;,
+      &quot;revisionnote&quot;: &quot;Revision note&quot;,
+      &quot;allowedall&quot;: &quot;yes&quot;,
+      &quot;arp&quot;:2,
+      &quot;workflow&quot;: &quot;testaccepted&quot;,
+      &quot;metadataurl&quot;: &quot;https://test-sp-1/metadata&quot;,
+      &quot;user&quot;: &quot;1&quot;,
+      &quot;metadata&quot;: {
+        &quot;AssertionConsumerService:0:Binding&quot;: &quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&quot;,
+        &quot;AssertionConsumerService:0:Location&quot;: &quot;https://test-sp-1/acs&quot;,
+        &quot;contacts:0:contactType&quot;: &quot;technical&quot;,
+        &quot;contacts:0:emailAddress&quot;: &quot;support@openconext.org&quot;,
+        &quot;contacts:0:givenName&quot;: &quot;Support&quot;,
+        &quot;contacts:0:surName&quot;: &quot;OpenConext&quot;,
+        &quot;contacts:1:contactType&quot;: &quot;support&quot;,
+        &quot;contacts:1:emailAddress&quot;: &quot;support@openconext.org&quot;,
+        &quot;contacts:1:givenName&quot;: &quot;Support&quot;,
+        &quot;contacts:1:surName&quot;: &quot;OpenConext&quot;,
+        &quot;contacts:2:contactType&quot;: &quot;administrative&quot;,
+        &quot;contacts:2:emailAddress&quot;: &quot;support@openconext.org&quot;,
+        &quot;contacts:2:givenName&quot;: &quot;Support&quot;,
+        &quot;contacts:2:surName&quot;: &quot;OpenConext&quot;,
+        &quot;name:en&quot;: &quot;Jmeter test-sp-1&quot;,
+        &quot;name:nl&quot;: &quot;Jmeter test-sp-1&quot;,
+        &quot;redirect.sign&quot;: false,
+        &quot;description:en&quot;: &quot;jmeter test-sp-1 description&quot;,
+        &quot;description:nl&quot;: &quot;jmeter test-sp-1 description&quot;,
+        &quot;logo:0:height&quot;: 96,
+        &quot;logo:0:url&quot;: &quot;https://static.demo.openconext.org/media/conext_logo.png&quot;,
+        &quot;logo:0:width&quot;: 96
+      }
+    }
+));
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Parse entity ID" enabled="true">
+            <stringProp name="filename"></stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+vars.put(&apos;sp_id&apos;, resp.result[0].eid);
+
+</stringProp>
+            <stringProp name="scriptLanguage">javascript</stringProp>
+          </BSFPostProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-2105097330">&quot;user&quot;:&quot;1&quot;</stringProp>
+              <stringProp name="430723818">&quot;allowedall&quot;:&quot;yes&quot;</stringProp>
+              <stringProp name="-1909640860">&quot;revisionid&quot;:&quot;0&quot;</stringProp>
+              <stringProp name="693515870">&quot;allowed&quot;:\[\]</stringProp>
+              <stringProp name="1877005218">&quot;blocked&quot;:\[\]</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Response Assertions (BSF)" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result[0].blocked.length !== 0) {
+  fail(&quot;Field &apos;blocked&apos; should be empty&quot;);
+}
+
+if (resp.result[0].allowed.length !== 0) {
+  fail(&quot;Field &apos;allowed&apos; should be empty&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Create new Service Provider (duplicate entityid)" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp</stringProp>
+          <stringProp name="HTTPSampler.method">PUT</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+  &quot;entityid&quot;: &quot;https://test-sp-1&quot;,
+}));
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="51508">400</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
+            <boolProp name="Assertion.assume_success">true</boolProp>
+            <intProp name="Assertion.test_type">8</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Create new Identity Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp</stringProp>
+          <stringProp name="HTTPSampler.method">PUT</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+      &quot;entityid&quot;: &quot;https://test-idp-1&quot;,
+      &quot;revisionnote&quot;: &quot;Revision note&quot;,
+      &quot;allowedall&quot;: &quot;yes&quot;,
+      &quot;workflow&quot;: &quot;testaccepted&quot;,
+      &quot;metadataurl&quot;: &quot;https://test-idp-1/metadata.xml&quot;,
+      &quot;user&quot;: &quot;1&quot;,
+      &quot;metadata&quot;: {
+        &quot;certData&quot;: &quot;cert-data-dummy&quot;,
+        &quot;coin:guest_qualifier&quot;: &quot;All&quot;,
+        &quot;contacts:0:contactType&quot;: &quot;technical&quot;,
+        &quot;contacts:0:emailAddress&quot;: &quot;support@openconext.org&quot;,
+        &quot;contacts:0:givenName&quot;: &quot;Support&quot;,
+        &quot;contacts:0:surName&quot;: &quot;OpenConext&quot;,
+        &quot;contacts:1:contactType&quot;: &quot;support&quot;,
+        &quot;contacts:1:emailAddress&quot;: &quot;support@openconext.org&quot;,
+        &quot;contacts:1:givenName&quot;: &quot;Support&quot;,
+        &quot;contacts:1:surName&quot;: &quot;OpenConext&quot;,
+        &quot;contacts:2:contactType&quot;: &quot;administrative&quot;,
+        &quot;contacts:2:emailAddress&quot;: &quot;support@openconext.org&quot;,
+        &quot;contacts:2:givenName&quot;: &quot;Support&quot;,
+        &quot;contacts:2:surName&quot;: &quot;OpenConext&quot;,
+        &quot;name:en&quot;: &quot;Jmeter test-idp-1&quot;,
+        &quot;name:nl&quot;: &quot;Jmeter test-idp-1&quot;,
+        &quot;SingleSignOnService:0:Binding&quot;: &quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&quot;,
+        &quot;SingleSignOnService:0:Location&quot;: &quot;https://test-idp-1/sso&quot;,
+        &quot;description:en&quot;: &quot;jmeter test idp 1&quot;,
+        &quot;description:nl&quot;: &quot;jmeter test idp 1&quot;,
+        &quot;keywords:en&quot;: &quot;openconext engine engineblock proxy sso saml2&quot;,
+        &quot;keywords:nl&quot;: &quot;openconext engine engineblock proxy sso saml2&quot;,
+        &quot;logo:0:height&quot;: 96,
+        &quot;logo:0:url&quot;: &quot;https://static.demo.openconext.org/media/conext_logo.png&quot;,
+        &quot;logo:0:width&quot;: 96
+      }
+    }
+));
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Parse entity ID" enabled="true">
+            <stringProp name="filename"></stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+vars.put(&apos;idp_id&apos;, resp.result[0].eid);
+
+</stringProp>
+            <stringProp name="scriptLanguage">javascript</stringProp>
+          </BSFPostProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1705091954">&quot;certData&quot;:&quot;cert-data-dummy&quot;</stringProp>
+              <stringProp name="430723818">&quot;allowedall&quot;:&quot;yes&quot;</stringProp>
+              <stringProp name="-1909640860">&quot;revisionid&quot;:&quot;0&quot;</stringProp>
+              <stringProp name="-168141545">&quot;name:en&quot;:&quot;Jmeter test-idp-1&quot;</stringProp>
+              <stringProp name="-2069017822">&quot;name:nl&quot;:&quot;Jmeter test-idp-1&quot;</stringProp>
+              <stringProp name="-1705091954">&quot;certData&quot;:&quot;cert-data-dummy&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Retrieve Service Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="407805293">&quot;AssertionConsumerService:0:Binding&quot;:&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&quot;</stringProp>
+              <stringProp name="-1909640860">&quot;revisionid&quot;:&quot;0&quot;</stringProp>
+              <stringProp name="-1298933059">&quot;arp&quot;:2</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Retrieve Identity Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp/${idp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1909640860">&quot;revisionid&quot;:&quot;0&quot;</stringProp>
+              <stringProp name="1075612587">&quot;entityid&quot;:&quot;https:\\/\\/test-idp-1&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Update ARP" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+  &quot;arp&quot;: ${arp_id}
+}));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on ARP ID" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;No results returned&quot;);
+}
+
+if (resp.result[0].revisionid != 1) {
+  fail(&quot;Expected rivision 1&quot;);
+}
+
+if (resp.result[0].arp != ${arp_id}) {
+  fail(&quot;Unexpected ARP ID&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Update contacts metadata" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+      &quot;metadata&quot;: {
+        &quot;contacts:0:contactType&quot;: &quot;tech&quot;,
+        &quot;contacts:0:emailAddress&quot;: &quot;support+1@openconext.org&quot;,
+        &quot;contacts:0:givenName&quot;: &quot;Support 1&quot;,
+        &quot;contacts:0:surName&quot;: &quot;OpenConext 1&quot;,
+      }
+    }
+));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1909640798">&quot;revisionid&quot;:&quot;2&quot;</stringProp>
+              <stringProp name="1359219635">&quot;contacts:0:givenName&quot;:&quot;Support 1&quot;</stringProp>
+              <stringProp name="-141683830">&quot;contacts:0:surName&quot;:&quot;OpenConext 1&quot;</stringProp>
+              <stringProp name="2016919469">&quot;contacts:0:contactType&quot;:&quot;tech&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Update certificate data" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+      &quot;metadata&quot;: {
+        &quot;certData&quot;: &quot;dummy certificate&quot;
+      }
+    }
+));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1242520035">&quot;certData&quot;:&quot;dummy certificate&quot;</stringProp>
+              <stringProp name="-1909640767">&quot;revisionid&quot;:&quot;3&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Update ACL allowed entities" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+    &quot;allowed&quot;: [${idp_id}],
+    &quot;allowedall&quot;: &quot;no&quot;,
+}));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1909640736">&quot;revisionid&quot;:&quot;4&quot;</stringProp>
+              <stringProp name="429525970">&quot;allowedall&quot;:&quot;no&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on allowed/blocked entities" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;No results returned&quot;);
+}
+
+if (resp.result[0].allowed.length !== 1) {
+  fail(&quot;Expected 1 allowed entity&quot;);
+}
+
+if (resp.result[0].allowed[0] != vars.get(&quot;idp_id&quot;)) {
+  fail(&quot;Bad allowed entity returned, POST failed?&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Update ACL blocked entities" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+    &quot;blocked&quot;: [${idp_id}],
+    &quot;allowed&quot;: [],
+    &quot;allowedall&quot;: &quot;yes&quot;,
+}));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1909640705">&quot;revisionid&quot;:&quot;5&quot;</stringProp>
+              <stringProp name="430723818">&quot;allowedall&quot;:&quot;yes&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on allowed/blocked entities" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;No results returned&quot;);
+}
+
+if (resp.result[0].allowed.length !== 0) {
+  fail(&quot;Expected no allowed entities&quot;);
+}
+
+if (resp.result[0].blocked.length !== 1) {
+  fail(&quot;Expected 1 blocked entity&quot;);
+}
+
+if (resp.result[0].blocked[0] != vars.get(&quot;idp_id&quot;)) {
+  fail(&quot;Bad blocked entity returned, POST failed?&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Disable consent" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp/${idp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+    &quot;disableconsent&quot;: [${sp_id}],
+}));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on disable consent" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;No results returned&quot;);
+}
+
+if (resp.result[0].disableconsent.length !== 1) {
+  fail(&quot;Expected 1 sp with disabled consent&quot;);
+}
+
+if (resp.result[0].disableconsent[0] != vars.get(&quot;sp_id&quot;)) {
+  fail(&quot;Bad disableconsent returned, POST failed?&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Remove disabled consent" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp/${idp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+    &quot;disableconsent&quot;: null, // or []
+}));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on disable consent" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;No results returned&quot;);
+}
+
+if (resp.result[0].disableconsent.length !== 0) {
+  fail(&quot;Expected no sp with disabled consent&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Update Service Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+  &quot;metadata&quot; : {
+      &quot;AssertionConsumerService:0:Binding&quot;:&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&quot;
+   }
+}));
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1387180015">&quot;AssertionConsumerService:0:Binding&quot;:&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Update Identity Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp/${idp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+      &quot;allowedall&quot;: &quot;no&quot;,
+      &quot;metadata&quot;: {
+        &quot;certData&quot;: &quot;cert-data-dummy-updated&quot;,
+        &quot;SingleSignOnService:0:Location&quot;: &quot;https://openidp.feide.no/simplesaml/saml2/idp/SSOService.php&quot;
+      },
+      &quot;allowed&quot;: [ ${sp_id} ],
+      &quot;disableconsent&quot;: [ ${sp_id} ]
+    }
+));
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="429525970">&quot;allowedall&quot;:&quot;no&quot;</stringProp>
+              <stringProp name="-1909640767">&quot;revisionid&quot;:&quot;3&quot;</stringProp>
+              <stringProp name="-1816938463">&quot;SingleSignOnService:0:Location&quot;:&quot;https:\\\/\\\/openidp.feide.no\\\/simplesaml\\\/saml2\\\/idp\\\/SSOService.php&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="Assertion on allowed/blocked entities" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">// decode JSON
+eval(&apos;var resp = &apos; + prev.getResponseDataAsString());
+
+// fail function
+function fail(msg) {
+  AssertionResult.setFailureMessage(msg); 
+  AssertionResult.setFailure(true);
+}
+
+if (resp.result.length === 0) {
+  fail(&quot;No results returned&quot;);
+}
+
+if (resp.result[0].allowed.length !== 1) {
+  fail(&quot;Expected 1 allowed entity&quot;);
+}
+
+if (resp.result[0].allowed[0] != vars.get(&quot;sp_id&quot;)) {
+  fail(&quot;Bad allowed entity returned, POST failed?&quot;);
+}
+
+if (resp.result[0].disableconsent.length !== 1) {
+  fail(&quot;Expected 1 disable consent entry&quot;);
+}
+
+if (resp.result[0].disableconsent[0] != vars.get(&quot;sp_id&quot;)) {
+  fail(&quot;Bad disable consent entity returned, POST failed?&quot;);
+}
+</stringProp>
+          </BSFAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Retrieve current revision" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="-1387180015">&quot;AssertionConsumerService:0:Binding&quot;:&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect&quot;</stringProp>
+              <stringProp name="-1909640674">&quot;revisionid&quot;:&quot;6&quot;</stringProp>
+              <stringProp name="-1317015447">&quot;contacts:0:emailAddress&quot;:&quot;support\+1\@openconext.org&quot;</stringProp>
+              <stringProp name="747404699">&quot;allowed&quot;:\[.+\]</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Retrieve old revision" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments"/>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}?revision=0</stringProp>
+          <stringProp name="HTTPSampler.method">GET</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="407805293">&quot;AssertionConsumerService:0:Binding&quot;:&quot;urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST&quot;</stringProp>
+              <stringProp name="-1909640860">&quot;revisionid&quot;:&quot;0&quot;</stringProp>
+              <stringProp name="-148209521">&quot;contacts:0:emailAddress&quot;:&quot;support@openconext.org&quot;</stringProp>
+              <stringProp name="693515870">&quot;allowed&quot;:\[\]</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Set workflow to production" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+  &quot;workflow&quot;: &quot;prodaccepted&quot;
+}));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="1733069115">&quot;workflow&quot;:&quot;prodaccepted&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Set workflow to test" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">POST</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree>
+          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Set request data" enabled="true">
+            <stringProp name="scriptLanguage">javascript</stringProp>
+            <stringProp name="parameters"></stringProp>
+            <stringProp name="filename"></stringProp>
+            <stringProp name="script">vars.put(&apos;request&apos;, vars.getObject(&apos;json&apos;).encode({
+  &quot;workflow&quot;: &quot;testaccepted&quot;
+}));
+
+
+</stringProp>
+          </BSFPreProcessor>
+          <hashTree/>
+          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertions" enabled="true">
+            <collectionProp name="Asserion.test_strings">
+              <stringProp name="1434262112">&quot;workflow&quot;:&quot;testaccepted&quot;</stringProp>
+            </collectionProp>
+            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
+            <boolProp name="Assertion.assume_success">false</boolProp>
+            <intProp name="Assertion.test_type">2</intProp>
+          </ResponseAssertion>
+          <hashTree/>
+        </hashTree>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Delete Service Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/sp/${sp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">DELETE</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree/>
+        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Delete Identity Provider" enabled="true">
+          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
+            <collectionProp name="Arguments.arguments">
+              <elementProp name="" elementType="HTTPArgument">
+                <boolProp name="HTTPArgument.always_encode">false</boolProp>
+                <stringProp name="Argument.value">${request}</stringProp>
+                <stringProp name="Argument.metadata">=</stringProp>
+                <boolProp name="HTTPArgument.use_equals">true</boolProp>
+              </elementProp>
+            </collectionProp>
+          </elementProp>
+          <stringProp name="HTTPSampler.domain"></stringProp>
+          <stringProp name="HTTPSampler.port"></stringProp>
+          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
+          <stringProp name="HTTPSampler.response_timeout"></stringProp>
+          <stringProp name="HTTPSampler.protocol"></stringProp>
+          <stringProp name="HTTPSampler.contentEncoding">utf8</stringProp>
+          <stringProp name="HTTPSampler.path">${base_path}/idp/${idp_id}</stringProp>
+          <stringProp name="HTTPSampler.method">DELETE</stringProp>
+          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
+          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
+          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
+          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
+          <boolProp name="HTTPSampler.monitor">false</boolProp>
+          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
+        </HTTPSamplerProxy>
+        <hashTree/>
+      </hashTree>
+      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
+        <boolProp name="ResultCollector.error_logging">false</boolProp>
+        <objProp>
+          <name>saveConfig</name>
+          <value class="SampleSaveConfiguration">
+            <time>true</time>
+            <latency>true</latency>
+            <timestamp>true</timestamp>
+            <success>true</success>
+            <label>true</label>
+            <code>true</code>
+            <message>true</message>
+            <threadName>true</threadName>
+            <dataType>true</dataType>
+            <encoding>false</encoding>
+            <assertions>true</assertions>
+            <subresults>true</subresults>
+            <responseData>false</responseData>
+            <samplerData>false</samplerData>
+            <xml>true</xml>
+            <fieldNames>false</fieldNames>
+            <responseHeaders>false</responseHeaders>
+            <requestHeaders>false</requestHeaders>
+            <responseDataOnError>false</responseDataOnError>
+            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
+            <assertionsResultsToSave>0</assertionsResultsToSave>
+            <bytes>true</bytes>
+          </value>
+        </objProp>
+        <stringProp name="filename"></stringProp>
+      </ResultCollector>
+      <hashTree/>
+    </hashTree>
+  </hashTree>
+</jmeterTestPlan>
diff --git a/www/module.php b/www/module.php
index 14bfd4c..8a2d728 100644
--- a/www/module.php
+++ b/www/module.php
@@ -43,10 +43,21 @@ try {
 
 	if (empty($_SERVER['PATH_INFO'])) {
 		throw new SimpleSAML_Error_NotFound('No PATH_INFO to module.php');
-	}	
+	}
 
 	$url = $_SERVER['PATH_INFO'];
-	assert('substr($url, 0, 1) === "/"');
+        assert('substr($url, 0, 1) === "/"');
+
+        // load configuration
+        $config = SimpleSAML_Configuration::getConfig('module_janus.php');
+
+        // setup REST API if configured
+        if ($config->hasValue('rest-api')) {
+            // rewrite REST v2 API URL (no index.php on user side)
+            if (strstr($url, 'index.php') === false) {
+                $url = str_replace('/rest-v2/', '/rest-v2/index.php/', $url);
+            }
+        }
 
 	/* Clear the PATH_INFO option, so that a script can detect whether it is called
 	 * with anything following the '.php'-ending.
@@ -182,4 +193,4 @@ try {
 
 }
 
-?>
\ No newline at end of file
+?>
